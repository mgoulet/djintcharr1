<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_26) on Mon Oct 10 21:40:19 CEST 2011 -->
<TITLE>
FrameBuffer
</TITLE>

<META NAME="date" CONTENT="2011-10-10">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="FrameBuffer";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/FrameBuffer.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/Config.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/GenericVertexController.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/threed/jpct/FrameBuffer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FrameBuffer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.threed.jpct</FONT>
<BR>
Class FrameBuffer</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.threed.jpct.FrameBuffer</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>FrameBuffer</B><DT>extends java.lang.Object<DT>implements java.io.Serializable</DL>
</PRE>

<P>
The FrameBuffer class provides a buffer into which jPCT renders the scene.
 The result is basically an Image which could be displayed or modified even
 further using some post-processing.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../serialized-form.html#com.threed.jpct.FrameBuffer">Serialized Form</A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#OPAQUE_BLITTING">OPAQUE_BLITTING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2D texture-blitting into the framebuffer is done by copying the source
 1-to-1 into the destination bitmap</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#TRANSPARENT_BLITTING">TRANSPARENT_BLITTING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2D texture-blitting into the framebuffer is done by copying the source
 into the destination bitmap only at places where the sources bitmap has
 none-zero color-values.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#FrameBuffer(GL10, int, int)">FrameBuffer</A></B>(GL10&nbsp;glContext,
            int&nbsp;x,
            int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new framebuffer with a width of x and a height of y.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#FrameBuffer(int, int)">FrameBuffer</A></B>(int&nbsp;x,
            int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new framebuffer with a width of x and a height of y.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#addPostProcessor(com.threed.jpct.IPostProcessor)">addPostProcessor</A></B>(<A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct">IPostProcessor</A>&nbsp;proc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an IPostProcessor to run a post processing on the framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(int[], int, int, int, int, int, int, int, int, boolean)">blit</A></B>(int[]&nbsp;src,
     int&nbsp;srcWidth,
     int&nbsp;srcHeight,
     int&nbsp;srcX,
     int&nbsp;srcY,
     int&nbsp;destX,
     int&nbsp;destY,
     int&nbsp;width,
     int&nbsp;height,
     boolean&nbsp;transparent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies a part of a bitmap (taken from an int[] containing pixels in
 RGB-format and with no alpha) into the framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(com.threed.jpct.Texture, int, int, int, int, int, int, boolean)">blit</A></B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
     int&nbsp;srcX,
     int&nbsp;srcY,
     int&nbsp;destX,
     int&nbsp;destY,
     int&nbsp;width,
     int&nbsp;height,
     boolean&nbsp;transparent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies a part of a bitmap (taken from a Texture in this case) into the
 framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(com.threed.jpct.Texture, int, int, int, int, int, int, int, int, int, boolean, com.threed.jpct.RGBColor)">blit</A></B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
     int&nbsp;srcX,
     int&nbsp;srcY,
     int&nbsp;destX,
     int&nbsp;destY,
     int&nbsp;sourceWidth,
     int&nbsp;sourceHeight,
     int&nbsp;destWidth,
     int&nbsp;destHeight,
     int&nbsp;transValue,
     boolean&nbsp;additive,
     <A HREF="../../../com/threed/jpct/RGBColor.html" title="class in com.threed.jpct">RGBColor</A>&nbsp;addColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special version of blit() that allows for scaling, i.e. it doesn't make
 1-to-1 copies but can up- or down-scale.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the framebuffer and the z-buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#clear(com.threed.jpct.RGBColor)">clear</A></B>(<A HREF="../../../com/threed/jpct/RGBColor.html" title="class in com.threed.jpct">RGBColor</A>&nbsp;col)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the framebuffer with the given color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#clearZBufferOnly()">clearZBufferOnly</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears only the ZBuffer, not the color buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#display()">display</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Displays the rendered image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#dispose()">dispose</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Should be called before this FrameBuffer won't be used anymore to do some
 clean up work.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#freeMemory()">freeMemory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees some native memory used by the gl context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getCenterX()">getCenterX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the x-coord of the midpoint of the framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getCenterY()">getCenterY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the y-coord of the midpoint of the framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getHeight()">getHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the height of the framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getID()">getID</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a unique ID for this FrameBuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getOpenGLMajorVersion()">getOpenGLMajorVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getPixels()">getPixels</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the raw pixel-data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getPixels(int[])">getPixels</A></B>(int[]&nbsp;toFill)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the raw pixel-data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getWidth()">getWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the width of the framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#isInitialized()">isInitialized</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the FrameBuffer and the renderer have been initialized
 correctly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#removeAllPostProcessors()">removeAllPostProcessors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all post processors from the framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#removePostProcessor(com.threed.jpct.IPostProcessor)">removePostProcessor</A></B>(<A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct">IPostProcessor</A>&nbsp;proc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a post processor from the framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#removeRenderTarget()">removeRenderTarget</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the render target from the framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#runPostProcessors()">runPostProcessors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runs all post processors that have been added to this framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setPaintListener(com.threed.jpct.IPaintListener)">setPaintListener</A></B>(<A HREF="../../../com/threed/jpct/IPaintListener.html" title="interface in com.threed.jpct">IPaintListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a listener to the renderer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setRenderTarget(int)">setRenderTarget</A></B>(int&nbsp;texID)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the render target of the framebuffer to a texture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setRenderTarget(int, int, int, int, int, boolean)">setRenderTarget</A></B>(int&nbsp;texID,
                int&nbsp;left,
                int&nbsp;top,
                int&nbsp;right,
                int&nbsp;bottom,
                boolean&nbsp;clearAll)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the render target of the framebuffer to a texture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setRenderTarget(com.threed.jpct.Texture)">setRenderTarget</A></B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;tex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the render target of the framebuffer to a texture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setRenderTarget(com.threed.jpct.Texture, int, int, int, int, boolean)">setRenderTarget</A></B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;tex,
                int&nbsp;left,
                int&nbsp;top,
                int&nbsp;right,
                int&nbsp;bottom,
                boolean&nbsp;clearAll)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the render target of the framebuffer to a texture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setVirtualDimensions(int, int)">setVirtualDimensions</A></B>(int&nbsp;width,
                     int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This has a meaning only if a render target has been set.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="OPAQUE_BLITTING"><!-- --></A><H3>
OPAQUE_BLITTING</H3>
<PRE>
public static final boolean <B>OPAQUE_BLITTING</B></PRE>
<DL>
<DD>2D texture-blitting into the framebuffer is done by copying the source
 1-to-1 into the destination bitmap
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.OPAQUE_BLITTING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRANSPARENT_BLITTING"><!-- --></A><H3>
TRANSPARENT_BLITTING</H3>
<PRE>
public static final boolean <B>TRANSPARENT_BLITTING</B></PRE>
<DL>
<DD>2D texture-blitting into the framebuffer is done by copying the source
 into the destination bitmap only at places where the sources bitmap has
 none-zero color-values.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.TRANSPARENT_BLITTING">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FrameBuffer(GL10, int, int)"><!-- --></A><H3>
FrameBuffer</H3>
<PRE>
public <B>FrameBuffer</B>(GL10&nbsp;glContext,
                   int&nbsp;x,
                   int&nbsp;y)</PRE>
<DL>
<DD>Creates a new framebuffer with a width of x and a height of y. The
 created buffer will be accessed by OpenGL ES 1.0/1.1. Make sure that your
 OpenGL context is 1.x before using this.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>glContext</CODE> - a valid gl context<DD><CODE>x</CODE> - the width of the framebuffer<DD><CODE>y</CODE> - the height of the framebuffer</DL>
</DL>
<HR>

<A NAME="FrameBuffer(int, int)"><!-- --></A><H3>
FrameBuffer</H3>
<PRE>
public <B>FrameBuffer</B>(int&nbsp;x,
                   int&nbsp;y)</PRE>
<DL>
<DD>Creates a new framebuffer with a width of x and a height of y. This
 constructor is for initializing the OpenGL ES2.0 pipeline. Make sure that
 your OpenGL context is 2.0 before using this.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the width of the framebuffer<DD><CODE>y</CODE> - the height of the framebuffer</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getID()"><!-- --></A><H3>
getID</H3>
<PRE>
public java.lang.Long <B>getID</B>()</PRE>
<DL>
<DD>Returns a unique ID for this FrameBuffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Long the ID</DL>
</DD>
</DL>
<HR>

<A NAME="getOpenGLMajorVersion()"><!-- --></A><H3>
getOpenGLMajorVersion</H3>
<PRE>
public int <B>getOpenGLMajorVersion</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isInitialized()"><!-- --></A><H3>
isInitialized</H3>
<PRE>
public boolean <B>isInitialized</B>()</PRE>
<DL>
<DD>Checks if the FrameBuffer and the renderer have been initialized
 correctly.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if the FrameBuffer is fine. Otherwise false.</DL>
</DD>
</DL>
<HR>

<A NAME="setRenderTarget(int)"><!-- --></A><H3>
setRenderTarget</H3>
<PRE>
public void <B>setRenderTarget</B>(int&nbsp;texID)</PRE>
<DL>
<DD>Sets the render target of the framebuffer to a texture. From here on, all
 rendering is done into that texture instead of the actual framebuffer.
 The texture has to be smaller or equal to the framebuffer. <br>
 While possible, it's not recommended to blit into a render target.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texID</CODE> - the ID of the texture to render into.</DL>
</DD>
</DL>
<HR>

<A NAME="setRenderTarget(int, int, int, int, int, boolean)"><!-- --></A><H3>
setRenderTarget</H3>
<PRE>
public void <B>setRenderTarget</B>(int&nbsp;texID,
                            int&nbsp;left,
                            int&nbsp;top,
                            int&nbsp;right,
                            int&nbsp;bottom,
                            boolean&nbsp;clearAll)</PRE>
<DL>
<DD>Sets the render target of the framebuffer to a texture. From here on, all
 rendering is done into that texture instead of the actual framebuffer.
 The texture has to be smaller or equal to the framebuffer, when FBO are
 not used/available. Rendering into a texture can be slow on some hardware
 like Intel onboard chipsets.<br>
 This is a special purpose version of this method that allows to define a
 border that isn't affected by the rendering. <br>
 While possible, it's not recommended to blit into a render target.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texID</CODE> - the ID of the texture to render into.<DD><CODE>left</CODE> - the width of the left border<DD><CODE>top</CODE> - the width of the upper border<DD><CODE>right</CODE> - the width of the right border<DD><CODE>bottom</CODE> - the width of the lower border<DD><CODE>clearAll</CODE> - if true, the border won't affect the clearing of texture. If
            set to false, it will.</DL>
</DD>
</DL>
<HR>

<A NAME="setRenderTarget(com.threed.jpct.Texture)"><!-- --></A><H3>
setRenderTarget</H3>
<PRE>
public void <B>setRenderTarget</B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;tex)</PRE>
<DL>
<DD>Sets the render target of the framebuffer to a texture. From here on, all
 rendering is done into that texture instead of the actual framebuffer.
 The texture has to be smaller or equal to the framebuffer. <br>
 While possible, it's not recommended to blit into a render target.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tex</CODE> - the texture to render into</DL>
</DD>
</DL>
<HR>

<A NAME="setRenderTarget(com.threed.jpct.Texture, int, int, int, int, boolean)"><!-- --></A><H3>
setRenderTarget</H3>
<PRE>
public void <B>setRenderTarget</B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;tex,
                            int&nbsp;left,
                            int&nbsp;top,
                            int&nbsp;right,
                            int&nbsp;bottom,
                            boolean&nbsp;clearAll)</PRE>
<DL>
<DD>Sets the render target of the framebuffer to a texture. From here on, all
 rendering is done into that texture instead of the actual framebuffer.
 The texture has to be smaller or equal to the framebuffer.<br/>
 This is a special purpose version of this method that allows to define a
 border that isn't affected by the rendering. <br>
 While possible, it's not recommended to blit into a render target.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tex</CODE> - the texture to render into<DD><CODE>left</CODE> - the width of the left border<DD><CODE>top</CODE> - the width of the upper border<DD><CODE>right</CODE> - the width of the right border<DD><CODE>bottom</CODE> - the width of the lower border<DD><CODE>clearAll</CODE> - if true, the border won't affect the clearing of texture. If
            set to false, it will.</DL>
</DD>
</DL>
<HR>

<A NAME="removeRenderTarget()"><!-- --></A><H3>
removeRenderTarget</H3>
<PRE>
public void <B>removeRenderTarget</B>()</PRE>
<DL>
<DD>Removes the render target from the framebuffer. After this, all rendering
 is done into the framebuffer again. If no render target has been set,
 this method does nothing.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setVirtualDimensions(int, int)"><!-- --></A><H3>
setVirtualDimensions</H3>
<PRE>
public void <B>setVirtualDimensions</B>(int&nbsp;width,
                                 int&nbsp;height)</PRE>
<DL>
<DD>This has a meaning only if a render target has been set. By default the
 fov calculations will use the render target's dimensions. With this, you
 can set some other dimensions.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>width</CODE> - the virtual width of the render target<DD><CODE>height</CODE> - the virtual height of the render target</DL>
</DD>
</DL>
<HR>

<A NAME="addPostProcessor(com.threed.jpct.IPostProcessor)"><!-- --></A><H3>
addPostProcessor</H3>
<PRE>
public void <B>addPostProcessor</B>(<A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct">IPostProcessor</A>&nbsp;proc)</PRE>
<DL>
<DD>Adds an IPostProcessor to run a post processing on the framebuffer. This
 isn't done automatically but has to be triggered by the application by
 calling runPostProcessors() on this framebuffer. Enabling or disabling
 renderers on this framebuffer causes all post processors to be disposed
 and then removed from this framebuffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>proc</CODE> - the post processor<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#runPostProcessors()"><CODE>runPostProcessors()</CODE></A>, 
<A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct"><CODE>IPostProcessor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removePostProcessor(com.threed.jpct.IPostProcessor)"><!-- --></A><H3>
removePostProcessor</H3>
<PRE>
public void <B>removePostProcessor</B>(<A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct">IPostProcessor</A>&nbsp;proc)</PRE>
<DL>
<DD>Removes a post processor from the framebuffer. The processor will be
 disposed and then removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>proc</CODE> - The post processor to be removed<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct"><CODE>IPostProcessor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeAllPostProcessors()"><!-- --></A><H3>
removeAllPostProcessors</H3>
<PRE>
public void <B>removeAllPostProcessors</B>()</PRE>
<DL>
<DD>Removes all post processors from the framebuffer. The processors will be
 disposed and then removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct"><CODE>IPostProcessor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="runPostProcessors()"><!-- --></A><H3>
runPostProcessors</H3>
<PRE>
public void <B>runPostProcessors</B>()</PRE>
<DL>
<DD>Runs all post processors that have been added to this framebuffer. A post
 processor is an implementation of the IPostProcessor interface. The
 processing is done on the framebuffer's back buffer in its current state,
 i.e. if you run it before blitting, the blitting won't be affected. If
 you run it afterwards, it will.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct"><CODE>IPostProcessor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setPaintListener(com.threed.jpct.IPaintListener)"><!-- --></A><H3>
setPaintListener</H3>
<PRE>
public void <B>setPaintListener</B>(<A HREF="../../../com/threed/jpct/IPaintListener.html" title="interface in com.threed.jpct">IPaintListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Adds a listener to the renderer. The listener will be notified before the
 renderer starts to paint polygons and after it has finished.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - IPaintListener the listener or null to clear it</DL>
</DD>
</DL>
<HR>

<A NAME="dispose()"><!-- --></A><H3>
dispose</H3>
<PRE>
public void <B>dispose</B>()</PRE>
<DL>
<DD>Should be called before this FrameBuffer won't be used anymore to do some
 clean up work. For example, if you are reusing a buffer variable to
 assign a new FrameBuffer for it, dispose the former one before doing so.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="freeMemory()"><!-- --></A><H3>
freeMemory</H3>
<PRE>
public void <B>freeMemory</B>()</PRE>
<DL>
<DD>Frees some native memory used by the gl context. Might be helpful to use
 this on a framebuffer, before the context is about to get lost, i.e.
 before the gl context becomes invalid.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getWidth()"><!-- --></A><H3>
getWidth</H3>
<PRE>
public int <B>getWidth</B>()</PRE>
<DL>
<DD>Returns the width of the framebuffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the width of the framebuffer</DL>
</DD>
</DL>
<HR>

<A NAME="getHeight()"><!-- --></A><H3>
getHeight</H3>
<PRE>
public int <B>getHeight</B>()</PRE>
<DL>
<DD>Returns the height of the framebuffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the height of the framebuffer</DL>
</DD>
</DL>
<HR>

<A NAME="getCenterX()"><!-- --></A><H3>
getCenterX</H3>
<PRE>
public float <B>getCenterX</B>()</PRE>
<DL>
<DD>Returns the x-coord of the midpoint of the framebuffer. This value
 represents the internally used width/2.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the x-coord</DL>
</DD>
</DL>
<HR>

<A NAME="getCenterY()"><!-- --></A><H3>
getCenterY</H3>
<PRE>
public float <B>getCenterY</B>()</PRE>
<DL>
<DD>Returns the y-coord of the midpoint of the framebuffer. This value
 represents the internally used height/2.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the y-coord</DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>()</PRE>
<DL>
<DD>Clears the framebuffer and the z-buffer. If you are not doing this every
 frame, it will lead to strange results on some devices...
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearZBufferOnly()"><!-- --></A><H3>
clearZBufferOnly</H3>
<PRE>
public void <B>clearZBufferOnly</B>()</PRE>
<DL>
<DD>Clears only the ZBuffer, not the color buffer. Can be useful for special
 effects like rendering two worlds into one frame buffer. Using this
 method may cause strange renderings on some devices, because they seem to
 rely on a cleared framebuffer each frame for an unknown reason.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clear(com.threed.jpct.RGBColor)"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>(<A HREF="../../../com/threed/jpct/RGBColor.html" title="class in com.threed.jpct">RGBColor</A>&nbsp;col)</PRE>
<DL>
<DD>Clears the framebuffer with the given color. If you are not doing this
 every frame, it will lead to strange results on some devices...
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>col</CODE> - the color the framebuffer is filled with</DL>
</DD>
</DL>
<HR>

<A NAME="getPixels()"><!-- --></A><H3>
getPixels</H3>
<PRE>
public int[] <B>getPixels</B>()</PRE>
<DL>
<DD>Returns the raw pixel-data. This can be useful, if one wants to copy
 parts of the FrameBuffer into an Image out of jPCT's focus. getPixels()
 should be called after calling update(), because otherwise it is not
 guaranteed that the returned array contains the most current pixels. The
 returned array contains the pixel-data in RGB-format and with no alpha
 information.<br>
 This method is very slow, because it has to read all the pixels out of
 the VRAM and write them into the FrameBuffer's internal pixel-buffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the pixels-array<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(com.threed.jpct.Texture, int, int, int, int, int, int, boolean)"><CODE>blit(com.threed.jpct.Texture src, int srcX, int srcY, int destX,
      int destY, int width, int height, boolean transparent)</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(int[], int, int, int, int, int, int, int, int, boolean)"><CODE>blit(int[] src, int srcWidth, int srcHeight, int srcX, int srcY,
      int destX, int destY, int width, int height, boolean transparent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPixels(int[])"><!-- --></A><H3>
getPixels</H3>
<PRE>
public int[] <B>getPixels</B>(int[]&nbsp;toFill)</PRE>
<DL>
<DD>Returns the raw pixel-data. This can be useful, if one wants to copy
 parts of the FrameBuffer into an Image out of jPCT's focus. getPixels()
 should be called after calling update(), because otherwise it is not
 guaranteed that the returned array contains the most current pixels. The
 returned array contains the pixel-data in RGB-format and with no alpha
 information.<br>
 This method is very slow, because it has to read all the pixels out of
 the VRAM and write them into the FrameBuffer's internal pixel-buffer.<br/>
 This method takes an array to fill. The array has to have to proper size
 (i.e. framebuffer's height*width).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toFill</CODE> - the array to fill
<DT><B>Returns:</B><DD>the pixels-array<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(com.threed.jpct.Texture, int, int, int, int, int, int, boolean)"><CODE>blit(com.threed.jpct.Texture src, int srcX, int srcY, int destX,
      int destY, int width, int height, boolean transparent)</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(int[], int, int, int, int, int, int, int, int, boolean)"><CODE>blit(int[] src, int srcWidth, int srcHeight, int srcX, int srcY,
      int destX, int destY, int width, int height, boolean transparent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="blit(com.threed.jpct.Texture, int, int, int, int, int, int, boolean)"><!-- --></A><H3>
blit</H3>
<PRE>
public void <B>blit</B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
                 int&nbsp;srcX,
                 int&nbsp;srcY,
                 int&nbsp;destX,
                 int&nbsp;destY,
                 int&nbsp;width,
                 int&nbsp;height,
                 boolean&nbsp;transparent)</PRE>
<DL>
<DD>Copies a part of a bitmap (taken from a Texture in this case) into the
 framebuffer. If you want your blitted content to lay on top of the
 rendered image, it has to be applied after calling update() on the
 buffer. This method is useful to copy 2D-GUI elements into the rendered
 image (or for similar tasks). Blitting requires that the current world
 has been rendered at least once into the framebuffer where the blitting
 should be applied to (for doing some intialization work). Usually, that
 shouldn't be a problem unless you are abusing jPCT as a "blitting engine"
 only. Be sure that the texture's height is 2^x. Everything else might
 produce unpredictable results. This method should be prefered over the
 int[]-array-blit whenever possible.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the texture that contains the source bitmap<DD><CODE>srcX</CODE> - the starting x-position in the source bitmap<DD><CODE>srcY</CODE> - the starting y-position in the source bitmap<DD><CODE>destX</CODE> - the starting x-position in the destination bitmap<DD><CODE>destY</CODE> - the starting y-position in the destination bitmap<DD><CODE>width</CODE> - the width of the region to copy<DD><CODE>height</CODE> - the height of the region to copy<DD><CODE>transparent</CODE> - black (or at least almost black) pixels won't be copied if
            this is set to TRANSPARENT_BLITTING. Any color-value which
            leads to a result of zero when "anded" with #f0f0f0 will be
            taken as black unless your texture specifies its own alpha
            channel.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#TRANSPARENT_BLITTING"><CODE>TRANSPARENT_BLITTING</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#OPAQUE_BLITTING"><CODE>OPAQUE_BLITTING</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="blit(com.threed.jpct.Texture, int, int, int, int, int, int, int, int, int, boolean, com.threed.jpct.RGBColor)"><!-- --></A><H3>
blit</H3>
<PRE>
public void <B>blit</B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
                 int&nbsp;srcX,
                 int&nbsp;srcY,
                 int&nbsp;destX,
                 int&nbsp;destY,
                 int&nbsp;sourceWidth,
                 int&nbsp;sourceHeight,
                 int&nbsp;destWidth,
                 int&nbsp;destHeight,
                 int&nbsp;transValue,
                 boolean&nbsp;additive,
                 <A HREF="../../../com/threed/jpct/RGBColor.html" title="class in com.threed.jpct">RGBColor</A>&nbsp;addColor)</PRE>
<DL>
<DD>Special version of blit() that allows for scaling, i.e. it doesn't make
 1-to-1 copies but can up- or down-scale. In addition, it offers support
 for transparency, a different blending mode and an additional color. If
 you want your blitted content to lay on top of the rendered image, it has
 to be applied after calling update() on the buffer. This method is useful
 to copy 2D-GUI elements into the rendered image (or for similar tasks).
 Blitting requires that the current world has been rendered at least once
 into the framebuffer where the blitting should be applied to (for doing
 some intialization work). Usually, that shouldn't be a problem unless you
 are abusing jPCT as a "blitting engine" only. There is no
 int[]-array-version of this method.<br>
 Using this method is quite to similar to using the Overlay-class. The
 difference is, that Overlay takes care of itself and that it has a real
 depth.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the texture that contains the source bitmap<DD><CODE>srcX</CODE> - the starting x-position in the source bitmap<DD><CODE>srcY</CODE> - the starting y-position in the source bitmap<DD><CODE>destX</CODE> - the starting x-position in the destination bitmap<DD><CODE>destY</CODE> - the starting y-position in the destination bitmap<DD><CODE>sourceWidth</CODE> - the width of the source region to copy<DD><CODE>sourceHeight</CODE> - the height of the source region to copy<DD><CODE>destWidth</CODE> - the width of the copied region in the destination bitmap<DD><CODE>destHeight</CODE> - the height of the copied region in the destination bitmap<DD><CODE>transValue</CODE> - the transparency value, -1 is none, 0 is highest transparency.
            Higher values mean less transparency.<DD><CODE>additive</CODE> - if true, the blending is additive, otherwise default<DD><CODE>addColor</CODE> - an additional color. If null, Color.WHITE is taken instead</DL>
</DD>
</DL>
<HR>

<A NAME="blit(int[], int, int, int, int, int, int, int, int, boolean)"><!-- --></A><H3>
blit</H3>
<PRE>
public void <B>blit</B>(int[]&nbsp;src,
                 int&nbsp;srcWidth,
                 int&nbsp;srcHeight,
                 int&nbsp;srcX,
                 int&nbsp;srcY,
                 int&nbsp;destX,
                 int&nbsp;destY,
                 int&nbsp;width,
                 int&nbsp;height,
                 boolean&nbsp;transparent)</PRE>
<DL>
<DD>Copies a part of a bitmap (taken from an int[] containing pixels in
 RGB-format and with no alpha) into the framebuffer. If you want your
 blitted content to lay on top of the rendered image, it has to be applied
 after calling update() on the buffer. Can be combined with getPixels() to
 achieve some special effects with the framebuffer.<br>
 Blitting requires that the current world has been rendered at least once
 into the framebuffer where the blitting should be applied to (for doing
 some intialization work). Usually, that shouldn't be a problem unless you
 are abusing jPCT as a "blitting engine" only. This method is very slow,
 because the int[] has to be converted and uploaded to the GPU every time.
 To avoid this in some cases, Config.glUseIgnorantBlits can be set to
 true...but one should be aware of the consequences. As a rule of thumb:
 If it's possible to avoid this method and use a texture-based-blit
 instead...do it!<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the int-array that contains the source bitmap<DD><CODE>srcWidth</CODE> - the width of the source bitmap<DD><CODE>srcHeight</CODE> - the height of the source bitmap<DD><CODE>srcX</CODE> - the starting x-position in the source bitmap<DD><CODE>srcY</CODE> - the starting y-position in the source bitmap<DD><CODE>destX</CODE> - the starting x-position in the destination bitmap<DD><CODE>destY</CODE> - the starting y-position in the destination bitmap<DD><CODE>width</CODE> - the width of the region to copy<DD><CODE>height</CODE> - the height of the region to copy<DD><CODE>transparent</CODE> - black (or at least almost black) pixels won't be copied if
            this is set to TRANSPARENT_BLITTING. Any color-value which
            leads to a result of zero when "anded" with #f0f0f0 will be
            taken as black.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#getPixels()"><CODE>getPixels()</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#TRANSPARENT_BLITTING"><CODE>TRANSPARENT_BLITTING</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#OPAQUE_BLITTING"><CODE>OPAQUE_BLITTING</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glUseIgnorantBlits"><CODE>Config.glUseIgnorantBlits</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="display()"><!-- --></A><H3>
display</H3>
<PRE>
public void <B>display</B>()</PRE>
<DL>
<DD>Displays the rendered image.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/FrameBuffer.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/Config.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/GenericVertexController.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/threed/jpct/FrameBuffer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FrameBuffer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
