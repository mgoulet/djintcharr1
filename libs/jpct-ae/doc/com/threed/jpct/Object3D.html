<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_26) on Mon Oct 10 21:40:19 CEST 2011 -->
<TITLE>
Object3D
</TITLE>

<META NAME="date" CONTENT="2011-10-10">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Object3D";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Object3D.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/threed/jpct/Object3D.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Object3D.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.threed.jpct</FONT>
<BR>
Class Object3D</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.threed.jpct.Object3D</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Object3D</B><DT>extends java.lang.Object<DT>implements java.io.Serializable</DL>
</PRE>

<P>
Object3D is a class for 3-dimensional objects. Don't let yourself fool by the
 similarity of the name to java.lang.Object. A 3-dimensional object as
 constructed by this class is usually added to an instance of World for
 rendering. One object should be added to only one instance of World at a
 time. Objects may be connected by defining them as childs/parents to build
 hierarchies among them. Dummy objects are also possible. They are usually not
 added to a World instance but binded to other objects (dummy or none-dummy).
 Some methods in this class require the instance to be added to an instance of
 World (using World.addObject()).
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html" title="class in com.threed.jpct"><CODE>World</CODE></A>, 
<A HREF="../../../serialized-form.html#com.threed.jpct.Object3D">Serialized Form</A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#BILLBOARDING_DISABLED">BILLBOARDING_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object won't use billboarding (default)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#BILLBOARDING_ENABLED">BILLBOARDING_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object will use billboarding (i.e. it always faces the camera)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_NONE">COLLISION_CHECK_NONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Don't perform any kind of collision detection for this object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_OTHERS">COLLISION_CHECK_OTHERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Other Object3Ds/rays/spheres/ellipsoids may collide with this object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_SELF">COLLISION_CHECK_SELF</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This Object3D may collide with other objects</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_DETECTION_NOT_OPTIMIZED">COLLISION_DETECTION_NOT_OPTIMIZED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables (default) an automated optimization for collision detection in
 case of problems with this optimization.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_DETECTION_OPTIMIZED">COLLISION_DETECTION_OPTIMIZED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables an automated optimization for speeding up collision detection in
 some case.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_NONE">COLLISION_NONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signals that no collision has been detected for this object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#CULLING_DISABLED">CULLING_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backface culling won't be applied to this object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#CULLING_ENABLED">CULLING_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backface culling will be applied to this object before rendering</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_ALIGNED">ELLIPSOID_ALIGNED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object's ellipsoid won't be transformed when performing collision
 detection (default).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_TRANSFORMED">ELLIPSOID_TRANSFORMED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object's ellipsoid will be transformed when performing collision
 detection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_DISABLED">ENVMAP_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Environment mapping is disabled</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_ENABLED">ENVMAP_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Environment mapping is enabled</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_ALL_ENABLED">LIGHTING_ALL_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that all kinds of light (lightsources, ambient and additional
 color) will be used on this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_NO_LIGHTS">LIGHTING_NO_LIGHTS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that no lightsources will be taken into account to calculate an
 object's lighting.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#NO_OBJECT">NO_OBJECT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The "ID" of an Object3D that doesn't exist.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#OBJ_INVISIBLE">OBJ_INVISIBLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object is invisible and won't be processed, rendered...nothing...</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#OBJ_VISIBLE">OBJ_VISIBLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object is visible</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#RAY_MISSES_BOX">RAY_MISSES_BOX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signals that a ray/box-intersection test has failed (the ray doesn't
 intersect with the box)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#SHADING_FAKED_FLAT">SHADING_FAKED_FLAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that (faked) flat shading should be used.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#SHADING_GOURAUD">SHADING_GOURAUD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that gouraud shading should be used (default)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#SPECULAR_DISABLED">SPECULAR_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specular highLights won't be calculated</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#SPECULAR_ENABLED">SPECULAR_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specular highLights will be calculated</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_ADD">TRANSPARENCY_MODE_ADD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An alternative transparency mode for additive blending.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_DEFAULT">TRANSPARENCY_MODE_DEFAULT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The default transparency mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#UNKNOWN_OBJECTSIZE">UNKNOWN_OBJECTSIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object is empty</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#Object3D(float[], float[], int[], int)">Object3D</A></B>(float[]&nbsp;coordinates,
         float[]&nbsp;uvs,
         int[]&nbsp;indices,
         int&nbsp;textureId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructor for creating an Object3D out of indexed geometry in bulk
 form.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#Object3D(int)">Object3D</A></B>(int&nbsp;maxTriangles)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new instance of Object3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#Object3D(com.threed.jpct.Object3D)">Object3D</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This constructor works similar to cloneObject() but it allows to extend
 Object3D and still use the static methods from Loader/Primitives by
 adding a call to super(Object3D) in the constructor of your class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#Object3D(com.threed.jpct.Object3D, boolean)">Object3D</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj,
         boolean&nbsp;reuseMesh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This constructor works similar to cloneObject() but it allows to extend
 Object3D and still use the static methods from Loader/Primitives by
 adding a call to super(Object3D) in the constructor of your class.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addChild(com.threed.jpct.Object3D)">addChild</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines an object as a child of this.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addCollisionListener(com.threed.jpct.CollisionListener)">addCollisionListener</A></B>(<A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct">CollisionListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a collision listener to this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addParent(com.threed.jpct.Object3D)">addParent</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines an object as a parent of this. this will inherit all
 transformations from its parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            float&nbsp;u,
            float&nbsp;v,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            float&nbsp;u2,
            float&nbsp;v2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
            float&nbsp;u3,
            float&nbsp;v3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, int)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            float&nbsp;u,
            float&nbsp;v,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            float&nbsp;u2,
            float&nbsp;v2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
            float&nbsp;u3,
            float&nbsp;v3,
            int&nbsp;textureID)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, int, int)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            float&nbsp;u,
            float&nbsp;v,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            float&nbsp;u2,
            float&nbsp;v2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
            float&nbsp;u3,
            float&nbsp;v3,
            int&nbsp;textureID,
            int&nbsp;sec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.TextureInfo)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
            <A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#align(com.threed.jpct.Camera)">align</A></B>(<A HREF="../../../com/threed/jpct/Camera.html" title="class in com.threed.jpct">Camera</A>&nbsp;camera)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aligns this object with a Camera using the camera's backbuffer matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#align(com.threed.jpct.Object3D)">align</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aligns this object with another Object3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#animate(float)">animate</A></B>(float&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates a new mesh for this object based on the keyframes of its
 animation sequence and "index". index is a value between 0 and 1 where 0
 is the first keyframe and 1 the last.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#animate(float, int)">animate</A></B>(float&nbsp;index,
        int&nbsp;seq)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates a new mesh for this object based on the keyframes of its
 animation sub-sequence and "index". index is a value between 0 and 1
 where 0 is the first keyframe and 1 the last (of the sub-sequence).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#build()">build</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes some basic object properties that are needed for almost all
 further processing. build() has to be called if the object is
 "ready to render" (loaded, Textures assigned, placed, rendering modes
 set, animations and vertex controllers assigned).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#build(boolean)">build</A></B>(boolean&nbsp;staticUV)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes some basic object properties that are needed for almost all
 further processing. build() has to be called if the object is
 "ready to render" (loaded, Textures assigned, placed, rendering modes
 set, animations and vertex controllers assigned).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcBoundingBox()">calcBoundingBox</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates an AABB (Axis Aligned Bounding Box) for this object in
 object-space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcCenter()">calcCenter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tries to calculate the center of the object using its mesh data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcMinDistance(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)">calcMinDistance</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal distance to some polygon of the object from a
 particular position vector looking into a specific direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcMinDistance(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)">calcMinDistance</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr,
                float&nbsp;ignoreIfLarger)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal distance to some polygon of the object from a
 particular position vector looking into a specific direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcNormals()">calcNormals</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates the object's vertex normals by calculating the face normals of
 the adjacent polygons of each vertex and averaging them.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcTangentVectors()">calcTangentVectors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tangent vectors are needed for some calculation in shaders.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcTextureWrap()">calcTextureWrap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Wraps" a texture around the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcTextureWrapSpherical()">calcTextureWrapSpherical</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Wraps" a texture around the object in a spherical way.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#checkForCollision(com.threed.jpct.SimpleVector, float)">checkForCollision</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dirVec,
                  float&nbsp;step)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current object collides with something when moving into a
 particular direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#checkForCollisionEllipsoid(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, int)">checkForCollisionEllipsoid</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                           <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid,
                           int&nbsp;recursionDepth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current object collides with something when moving into a
 particular direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#checkForCollisionSpherical(com.threed.jpct.SimpleVector, float)">checkForCollisionSpherical</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                           float&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current object collides with something when moving into a
 particular direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#clearAdditionalColor()">clearAdditionalColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes additional color information form the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#clearAnimation()">clearAnimation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the animation for this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#clearObject()">clearObject</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the object by removing all vertex/mesh information from it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#clearRotation()">clearRotation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets the current rotation to the initial value, i.e. no rotation at
 all.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#clearShader()">clearShader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a shader and reverts to the default shader set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#clearTranslation()">clearTranslation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets the current translation to the initial value, i.e. no translation
 at all.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#cloneObject()">cloneObject</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones the current object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#compile()">compile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mainly needed to ease porting from the desktop version of jPCT.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#compile(boolean, boolean)">compile</A></B>(boolean&nbsp;dynamic,
        boolean&nbsp;staticUV)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mainly needed to ease porting from the desktop version of jPCT.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#createDummyObj()">createDummyObj</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Static method that creates a dummy Object3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#cullingIsInverted()">cullingIsInverted</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true, if inverted culling is used on this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#decoupleMesh()">decoupleMesh</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decouples the current mesh from the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#disableCollisionListeners()">disableCollisionListeners</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables all collision listeners of this object, so that none of them
 will be notified in case of a collision.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#disableLazyTransformations()">disableLazyTransformations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables "lazy transformations".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#disableVertexSharing()">disableVertexSharing</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables the automatic vertex sharing that jPCT does for triangles added
 by addTriangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ellipsoidIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)">ellipsoidIntersectsAABB</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                        <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a given ellipsoid intersects the axis aligned bounding box (in
 object-space) of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#enableCollisionListeners()">enableCollisionListeners</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Re-)enables all collision listerner of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#enableLazyTransformations()">enableLazyTransformations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables "lazy transformations".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#forceGeometryIndices(boolean)">forceGeometryIndices</A></B>(boolean&nbsp;force)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forces the object to be compiled to indexed geometry no matter what.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/RGBColor.html" title="class in com.threed.jpct">RGBColor</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getAdditionalColor()">getAdditionalColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the additional color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct">Animation</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getAnimationSequence()">getAnimationSequence</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the animation sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getCenter()">getCenter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the center of the object (in object-space, i.e. unaffected by any
 transformation).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Iterator&lt;<A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct">CollisionListener</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getCollisionListeners()">getCollisionListeners</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the collision listeners of this object as an enumeration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getCulling()">getCulling</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current culling mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getEllipsoidMode()">getEllipsoidMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current ellipsoid mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getID()">getID</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the object's ID.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getInverseWorldTransformation()">getInverseWorldTransformation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getInverseWorldTransformation(com.threed.jpct.Matrix)">getInverseWorldTransformation</A></B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getLightCount()">getLightCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of lights that have an influence on this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getLighting()">getLighting</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the lighting mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct">Mesh</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getMesh()">getMesh</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current mesh of the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getName()">getName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the name of the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getNextID()">getNextID</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Static method that returns the ID the next object will get.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct">OcTree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getOcTree()">getOcTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the OcTree assigned to this object or null, if none has been
 assigned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getOrigin()">getOrigin</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the origin of the object (as set by setOrigin()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getOriginMatrix()">getOriginMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the object's origin-translation matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getParents()">getParents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all parents of this Object3D in an array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/PolygonManager.html" title="class in com.threed.jpct">PolygonManager</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getPolygonManager()">getPolygonManager</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the PolygonManager for this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getRotationMatrix()">getRotationMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the object's current rotation matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getRotationPivot()">getRotationPivot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the rotation pivot of the object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getScale()">getScale</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the cumulated scale value for this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTextureMatrix()">getTextureMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current texture matrix of null if none is set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTransformedCenter()">getTransformedCenter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the center of the object in worldspace, i.e. after the object's
 current transformations have been applied to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTransformedCenter(com.threed.jpct.SimpleVector)">getTransformedCenter</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;toFill)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the center of the object in worldspace, i.e. after the object's
 current transformations have been applied to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTranslation()">getTranslation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the translation of the object (from its origin to its current
 position)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTranslation(com.threed.jpct.SimpleVector)">getTranslation</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;trns)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the translation of the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTranslationMatrix()">getTranslationMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the object's current translation matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTransparency()">getTransparency</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current tranparency setting.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTransparencyMode()">getTransparencyMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current transparency mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getUserObject()">getUserObject</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the user defined object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getVisibility()">getVisibility</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current visibility state of the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getWorldTransformation()">getWorldTransformation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the transformation matrix used to transform the object from
 objectspace into worldspace.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getWorldTransformation(com.threed.jpct.Matrix)">getWorldTransformation</A></B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variant of getWorldTransformation() to avoid the creation of an
 additional matrix where not needed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getXAxis()">getXAxis</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the x-axis of the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getYAxis()">getYAxis</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the y-axis of the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getZAxis()">getZAxis</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the z-axis of the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#hasChild(com.threed.jpct.Object3D)">hasChild</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests an object for being a child object of the current object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#hasParent(com.threed.jpct.Object3D)">hasParent</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests an object for being a parent object of the current object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#hasVertexAlpha()">hasVertexAlpha</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true, if this object uses vertex alpha values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#invert()">invert</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Physically "inverts" the object, which means that the backface culling
 works the other way round.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#invertCulling(boolean)">invertCulling</A></B>(boolean&nbsp;inv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inverts culling order if set to true.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#isEnvmapped()">isEnvmapped</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if environment mapping is used or not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#isTransparent()">isTransparent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if the object is transparent of not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#mergeAll(com.threed.jpct.Object3D[])">mergeAll</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>[]&nbsp;objs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merges all objects in the array into one large object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#mergeObjects(com.threed.jpct.Object3D, com.threed.jpct.Object3D)">mergeObjects</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;first,
             <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;second)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Static method that merges two objects into a third one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rayIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)">rayIntersectsAABB</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                  <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a given ray intersects with the axis aligned bounding box (in
 object-space) of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rayIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, boolean)">rayIntersectsAABB</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                  <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr,
                  boolean&nbsp;isNormalized)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a given ray intersects with the axis aligned bounding box (in
 object-space) of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#removeChild(com.threed.jpct.Object3D)">removeChild</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes an object from the child-collection of this.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#removeCollisionListener(com.threed.jpct.CollisionListener)">removeCollisionListener</A></B>(<A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct">CollisionListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a collision listener from the list of listeners.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#removeParent(com.threed.jpct.Object3D)">removeParent</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes an object from the parent-collection of this.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#resetCollisionStatus()">resetCollisionStatus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the indicator that the object was a target of the last collision
 detection to false, i.e. the object won't be recognized any longer as
 part of the collision.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#resetNextID()">resetNextID</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets the internal object-counter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rotateAxis(com.threed.jpct.SimpleVector, float)">rotateAxis</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;axis,
           float&nbsp;angle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the object's rotation matrix around an arbitrary axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rotateMesh()">rotateMesh</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the raw mesh data using the rotation matrix specified for this
 object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rotateX(float)">rotateX</A></B>(float&nbsp;w)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the object's rotation matrix around the x-axis by the given angle
 w (radian, counter clockwise for positive values).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rotateY(float)">rotateY</A></B>(float&nbsp;w)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the object's rotation matrix around the y-axis by the given angle
 w (radian, clockwise for positive values).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rotateZ(float)">rotateZ</A></B>(float&nbsp;w)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the object's rotation matrix around the z-axis by the given angle
 w (radian, counter clockwise for positive values).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#scale(float)">scale</A></B>(float&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scales the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setAdditionalColor(com.threed.jpct.RGBColor)">setAdditionalColor</A></B>(<A HREF="../../../com/threed/jpct/RGBColor.html" title="class in com.threed.jpct">RGBColor</A>&nbsp;col)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the additional color for this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setAnimationSequence(com.threed.jpct.Animation)">setAnimationSequence</A></B>(<A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct">Animation</A>&nbsp;anim)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the keyframe animation sequence that should be used for this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setBillboarding(boolean)">setBillboarding</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/disables billboarding for this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setBoundingBox(float, float, float, float, float, float)">setBoundingBox</A></B>(float&nbsp;minx,
               float&nbsp;maxx,
               float&nbsp;miny,
               float&nbsp;maxy,
               float&nbsp;minz,
               float&nbsp;maxz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a new AABB for the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setCenter(com.threed.jpct.SimpleVector)">setCenter</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;center)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the center of the object (in object-space).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setCollisionMode(int)">setCollisionMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets if and how the object will respond to collisions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setCollisionOptimization(boolean)">setCollisionOptimization</A></B>(boolean&nbsp;optimized)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets an optimization for collision detection to be used/not used.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setCulling(boolean)">setCulling</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/Disables backface culling for the current object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setEllipsoidMode(int)">setEllipsoidMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When doing ellipsoid collision detection with this object, the ellipsoid
 can be transformed according to the objects's transformation and in the
 source's object space or it remains static in the target's object space
 (i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setEnvmapped(boolean)">setEnvmapped</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/Disables environment mapping for the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setFixedPointMode(boolean)">setFixedPointMode</A></B>(boolean&nbsp;useFixedPoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set to true, some operations will be using fixed point instead of
 floating point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setLighting(int)">setLighting</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the lighting mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setMesh(com.threed.jpct.Mesh)">setMesh</A></B>(<A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct">Mesh</A>&nbsp;mesh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets an object's mesh to another one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setName(java.lang.String)">setName</A></B>(java.lang.String&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the name of the object to a name other than the default one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setNextID(int)">setNextID</A></B>(int&nbsp;next)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the ID the next object will get.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setOcTree(com.threed.jpct.OcTree)">setOcTree</A></B>(<A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct">OcTree</A>&nbsp;ocTree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assigns an octree to the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setOrientation(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)">setOrientation</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dir,
               <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;up)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the orientation of this object by giving a direction and an
 up-vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setOrigin(com.threed.jpct.SimpleVector)">setOrigin</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;origin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the origin of the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setRenderHook(com.threed.jpct.IRenderHook)">setRenderHook</A></B>(<A HREF="../../../com/threed/jpct/IRenderHook.html" title="interface in com.threed.jpct">IRenderHook</A>&nbsp;hook)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a new hook into the rendering pipeline.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setRotationMatrix(com.threed.jpct.Matrix)">setRotationMatrix</A></B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the rotation matrix for the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setRotationPivot(com.threed.jpct.SimpleVector)">setRotationPivot</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;pivot)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the rotation pivot of the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setScale(float)">setScale</A></B>(float&nbsp;absScale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets an absolute value for the object's scaling.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setShader(com.threed.jpct.GLSLShader)">setShader</A></B>(<A HREF="../../../com/threed/jpct/GLSLShader.html" title="class in com.threed.jpct">GLSLShader</A>&nbsp;shader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a shader other than the default shader set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setShadingMode(int)">setShadingMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jPCT always uses gouraud shading and that can't be disabled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setSortOffset(float)">setSortOffset</A></B>(float&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets on offset for the z-Sorting.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setSpecularLighting(boolean)">setSpecularLighting</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/Disables specular lighting for the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTexture(java.lang.String)">setTexture</A></B>(java.lang.String&nbsp;texname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the texture for the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTexture(com.threed.jpct.TextureInfo)">setTexture</A></B>(<A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the texture for the object via an instance of TextureInfo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTextureMatrix(com.threed.jpct.Matrix)">setTextureMatrix</A></B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a matrix that is applied to transform the texture in stage 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTranslationMatrix(com.threed.jpct.Matrix)">setTranslationMatrix</A></B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the translation matrix for the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTransparency(int)">setTransparency</A></B>(int&nbsp;trans)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the object to be transparent using the given level of transparency.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTransparencyMode(int)">setTransparencyMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the transparency (blending) mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setUserObject(java.lang.Object)">setUserObject</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is a "workaround" in case you want to give additional
 information to an Object3D but don't want to (or can't) extend Object3D
 itself.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setVisibility(boolean)">setVisibility</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the object to visible/invisible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#shareCompiledData(com.threed.jpct.Object3D)">shareCompiledData</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;withObj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables a compiled object to share data with another compiled one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#sphereIntersectsAABB(com.threed.jpct.SimpleVector, float)">sphereIntersectsAABB</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                     float&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a given sphere intersects the axis aligned bounding box (in
 object-space) of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#strip()">strip</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees some memory by stripping some data that isn't needed anymore unless
 you want to modify the object afterwards by using a PolygonManager.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#touch()">touch</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Touches an object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#translate(float, float, float)">translate</A></B>(float&nbsp;x,
          float&nbsp;y,
          float&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translates ("moves") the object in worldspace by modifying the
 translation matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#translate(com.threed.jpct.SimpleVector)">translate</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;trans)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translates ("moves") the object in worldspace by modifying the
 translation matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#translateMesh()">translateMesh</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translates the raw mesh data using the translation and the origin matrix
 of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#wasTargetOfLastCollision()">wasTargetOfLastCollision</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True, if this object was a target of the last collision detection that
 took place (regardless of what kind it was).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#wasVisible()">wasVisible</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if the object was visible (or at least supposed to be) in the
 last frame.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ENVMAP_ENABLED"><!-- --></A><H3>
ENVMAP_ENABLED</H3>
<PRE>
public static final boolean <B>ENVMAP_ENABLED</B></PRE>
<DL>
<DD>Environment mapping is enabled
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ENVMAP_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ENVMAP_DISABLED"><!-- --></A><H3>
ENVMAP_DISABLED</H3>
<PRE>
public static final boolean <B>ENVMAP_DISABLED</B></PRE>
<DL>
<DD>Environment mapping is disabled
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ENVMAP_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRANSPARENCY_MODE_DEFAULT"><!-- --></A><H3>
TRANSPARENCY_MODE_DEFAULT</H3>
<PRE>
public static final int <B>TRANSPARENCY_MODE_DEFAULT</B></PRE>
<DL>
<DD>The default transparency mode.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.TRANSPARENCY_MODE_DEFAULT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRANSPARENCY_MODE_ADD"><!-- --></A><H3>
TRANSPARENCY_MODE_ADD</H3>
<PRE>
public static final int <B>TRANSPARENCY_MODE_ADD</B></PRE>
<DL>
<DD>An alternative transparency mode for additive blending.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.TRANSPARENCY_MODE_ADD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BILLBOARDING_ENABLED"><!-- --></A><H3>
BILLBOARDING_ENABLED</H3>
<PRE>
public static final boolean <B>BILLBOARDING_ENABLED</B></PRE>
<DL>
<DD>The object will use billboarding (i.e. it always faces the camera)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.BILLBOARDING_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BILLBOARDING_DISABLED"><!-- --></A><H3>
BILLBOARDING_DISABLED</H3>
<PRE>
public static final boolean <B>BILLBOARDING_DISABLED</B></PRE>
<DL>
<DD>The object won't use billboarding (default)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.BILLBOARDING_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CULLING_ENABLED"><!-- --></A><H3>
CULLING_ENABLED</H3>
<PRE>
public static final boolean <B>CULLING_ENABLED</B></PRE>
<DL>
<DD>Backface culling will be applied to this object before rendering
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.CULLING_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CULLING_DISABLED"><!-- --></A><H3>
CULLING_DISABLED</H3>
<PRE>
public static final boolean <B>CULLING_DISABLED</B></PRE>
<DL>
<DD>Backface culling won't be applied to this object
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.CULLING_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SPECULAR_ENABLED"><!-- --></A><H3>
SPECULAR_ENABLED</H3>
<PRE>
public static final boolean <B>SPECULAR_ENABLED</B></PRE>
<DL>
<DD>Specular highLights will be calculated
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.SPECULAR_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SPECULAR_DISABLED"><!-- --></A><H3>
SPECULAR_DISABLED</H3>
<PRE>
public static final boolean <B>SPECULAR_DISABLED</B></PRE>
<DL>
<DD>Specular highLights won't be calculated
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.SPECULAR_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OBJ_VISIBLE"><!-- --></A><H3>
OBJ_VISIBLE</H3>
<PRE>
public static final boolean <B>OBJ_VISIBLE</B></PRE>
<DL>
<DD>The object is visible
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.OBJ_VISIBLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OBJ_INVISIBLE"><!-- --></A><H3>
OBJ_INVISIBLE</H3>
<PRE>
public static final boolean <B>OBJ_INVISIBLE</B></PRE>
<DL>
<DD>The object is invisible and won't be processed, rendered...nothing...
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.OBJ_INVISIBLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_CHECK_NONE"><!-- --></A><H3>
COLLISION_CHECK_NONE</H3>
<PRE>
public static final int <B>COLLISION_CHECK_NONE</B></PRE>
<DL>
<DD>Don't perform any kind of collision detection for this object
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_CHECK_NONE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_CHECK_OTHERS"><!-- --></A><H3>
COLLISION_CHECK_OTHERS</H3>
<PRE>
public static final int <B>COLLISION_CHECK_OTHERS</B></PRE>
<DL>
<DD>Other Object3Ds/rays/spheres/ellipsoids may collide with this object
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_CHECK_OTHERS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_CHECK_SELF"><!-- --></A><H3>
COLLISION_CHECK_SELF</H3>
<PRE>
public static final int <B>COLLISION_CHECK_SELF</B></PRE>
<DL>
<DD>This Object3D may collide with other objects
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_CHECK_SELF">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_NONE"><!-- --></A><H3>
COLLISION_NONE</H3>
<PRE>
public static final float <B>COLLISION_NONE</B></PRE>
<DL>
<DD>Signals that no collision has been detected for this object
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_NONE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RAY_MISSES_BOX"><!-- --></A><H3>
RAY_MISSES_BOX</H3>
<PRE>
public static final float <B>RAY_MISSES_BOX</B></PRE>
<DL>
<DD>Signals that a ray/box-intersection test has failed (the ray doesn't
 intersect with the box)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.RAY_MISSES_BOX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_DETECTION_OPTIMIZED"><!-- --></A><H3>
COLLISION_DETECTION_OPTIMIZED</H3>
<PRE>
public static final boolean <B>COLLISION_DETECTION_OPTIMIZED</B></PRE>
<DL>
<DD>Enables an automated optimization for speeding up collision detection in
 some case. May cause problems on dynamically changing geometry.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_DETECTION_OPTIMIZED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_DETECTION_NOT_OPTIMIZED"><!-- --></A><H3>
COLLISION_DETECTION_NOT_OPTIMIZED</H3>
<PRE>
public static final boolean <B>COLLISION_DETECTION_NOT_OPTIMIZED</B></PRE>
<DL>
<DD>Disables (default) an automated optimization for collision detection in
 case of problems with this optimization.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_DETECTION_NOT_OPTIMIZED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SHADING_GOURAUD"><!-- --></A><H3>
SHADING_GOURAUD</H3>
<PRE>
public static final int <B>SHADING_GOURAUD</B></PRE>
<DL>
<DD>Indicates that gouraud shading should be used (default)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.SHADING_GOURAUD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SHADING_FAKED_FLAT"><!-- --></A><H3>
SHADING_FAKED_FLAT</H3>
<PRE>
public static final int <B>SHADING_FAKED_FLAT</B></PRE>
<DL>
<DD>Indicates that (faked) flat shading should be used. Faked, because it
 sits on top of gouraud, i.e. it's not faster than using gouraud shading.
 In fact it may be slower because it hinders the usage of triangle strips.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.SHADING_FAKED_FLAT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LIGHTING_ALL_ENABLED"><!-- --></A><H3>
LIGHTING_ALL_ENABLED</H3>
<PRE>
public static final int <B>LIGHTING_ALL_ENABLED</B></PRE>
<DL>
<DD>Indicates that all kinds of light (lightsources, ambient and additional
 color) will be used on this object. This is default.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.LIGHTING_ALL_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LIGHTING_NO_LIGHTS"><!-- --></A><H3>
LIGHTING_NO_LIGHTS</H3>
<PRE>
public static final int <B>LIGHTING_NO_LIGHTS</B></PRE>
<DL>
<DD>Indicates that no lightsources will be taken into account to calculate an
 object's lighting. Ambient light and the additional color will be used.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.LIGHTING_NO_LIGHTS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ELLIPSOID_ALIGNED"><!-- --></A><H3>
ELLIPSOID_ALIGNED</H3>
<PRE>
public static final int <B>ELLIPSOID_ALIGNED</B></PRE>
<DL>
<DD>The object's ellipsoid won't be transformed when performing collision
 detection (default).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ELLIPSOID_ALIGNED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ELLIPSOID_TRANSFORMED"><!-- --></A><H3>
ELLIPSOID_TRANSFORMED</H3>
<PRE>
public static final int <B>ELLIPSOID_TRANSFORMED</B></PRE>
<DL>
<DD>The object's ellipsoid will be transformed when performing collision
 detection.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ELLIPSOID_TRANSFORMED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="UNKNOWN_OBJECTSIZE"><!-- --></A><H3>
UNKNOWN_OBJECTSIZE</H3>
<PRE>
public static final int <B>UNKNOWN_OBJECTSIZE</B></PRE>
<DL>
<DD>The object is empty
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.UNKNOWN_OBJECTSIZE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NO_OBJECT"><!-- --></A><H3>
NO_OBJECT</H3>
<PRE>
public static final int <B>NO_OBJECT</B></PRE>
<DL>
<DD>The "ID" of an Object3D that doesn't exist. If a method that usually
 returns an Object-ID returns this value, no appropiate Object3D has been
 found.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.NO_OBJECT">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Object3D(float[], float[], int[], int)"><!-- --></A><H3>
Object3D</H3>
<PRE>
public <B>Object3D</B>(float[]&nbsp;coordinates,
                float[]&nbsp;uvs,
                int[]&nbsp;indices,
                int&nbsp;textureId)</PRE>
<DL>
<DD>Constructor for creating an Object3D out of indexed geometry in bulk
 form. This can be useful to create an Object3D at once from data loaded
 by one's own file loader.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>coordinates</CODE> - the coordinates [x1,y1,z1,x2,y2,z2,...]<DD><CODE>uvs</CODE> - the texture coordinates [u1,v1,u2,v2,...]<DD><CODE>indices</CODE> - the indices indexing the tuples/triples in the coordinate
            arrays<DD><CODE>textureId</CODE> - the texture id. If not known, just use
            TextureManager.TEXTURE_NOTFOUND</DL>
</DL>
<HR>

<A NAME="Object3D(int)"><!-- --></A><H3>
Object3D</H3>
<PRE>
public <B>Object3D</B>(int&nbsp;maxTriangles)</PRE>
<DL>
<DD>Creates a new instance of Object3D. Usually, an object is created to be
 added to some instance of World. You may also create dummy objects, that
 are just "lending" there transformations to their child-objects, but this
 should be done by using createDummyObj().
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>maxTriangles</CODE> - the maximum number of triangles for this object.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#createDummyObj()"><CODE>createDummyObj()</CODE></A></DL>
</DL>
<HR>

<A NAME="Object3D(com.threed.jpct.Object3D)"><!-- --></A><H3>
Object3D</H3>
<PRE>
public <B>Object3D</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>This constructor works similar to cloneObject() but it allows to extend
 Object3D and still use the static methods from Loader/Primitives by
 adding a call to super(Object3D) in the constructor of your class.
 Consider this to be a kind of "workaround" for the fact that you can't
 extend a loaded (by Loader) or created (by Primitives) Object3D directly.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the Object3D to construct this Object3D from</DL>
</DL>
<HR>

<A NAME="Object3D(com.threed.jpct.Object3D, boolean)"><!-- --></A><H3>
Object3D</H3>
<PRE>
public <B>Object3D</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj,
                boolean&nbsp;reuseMesh)</PRE>
<DL>
<DD>This constructor works similar to cloneObject() but it allows to extend
 Object3D and still use the static methods from Loader/Primitives by
 adding a call to super(Object3D) in the constructor of your class.
 Consider this to be a kind of "workaround" for the fact that you can't
 extend a loaded (by Loader) or created (by Primitives) Object3D directly.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the Object3D to construct this Object3D from<DD><CODE>reuseMesh</CODE> - if true, the new object will use the same mesh</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="createDummyObj()"><!-- --></A><H3>
createDummyObj</H3>
<PRE>
public static <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A> <B>createDummyObj</B>()</PRE>
<DL>
<DD>Static method that creates a dummy Object3D. This dummy object is
 basically a normal but empty object. This method should be used to create
 an object that won't be added to the world but linked to another object
 as a child object. This could be useful to enhance the flexiblity of the
 object bindings (like a moon spinning around a planet...it may be useful
 to link the moon to the planet via a dummy object placed in the planet's
 center. This enables the moon not only to inherit the transformations of
 the planet but also the transformations of the dummy object). There is no
 need nor any sense in adding a dummy object directly to the world.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a dummy Object3D<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#addObject(com.threed.jpct.Object3D)"><CODE>World.addObject(com.threed.jpct.Object3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setUserObject(java.lang.Object)"><!-- --></A><H3>
setUserObject</H3>
<PRE>
public void <B>setUserObject</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>This method is a "workaround" in case you want to give additional
 information to an Object3D but don't want to (or can't) extend Object3D
 itself.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - Object whatever you like...</DL>
</DD>
</DL>
<HR>

<A NAME="getUserObject()"><!-- --></A><H3>
getUserObject</H3>
<PRE>
public java.lang.Object <B>getUserObject</B>()</PRE>
<DL>
<DD>Return the user defined object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Object the Object</DL>
</DD>
</DL>
<HR>

<A NAME="setSortOffset(float)"><!-- --></A><H3>
setSortOffset</H3>
<PRE>
public void <B>setSortOffset</B>(float&nbsp;offset)</PRE>
<DL>
<DD>Sets on offset for the z-Sorting. Usually this is not needed, but it
 could be helpful for transparent objects that are sorted incorrectly
 otherwise.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - the offset</DL>
</DD>
</DL>
<HR>

<A NAME="mergeObjects(com.threed.jpct.Object3D, com.threed.jpct.Object3D)"><!-- --></A><H3>
mergeObjects</H3>
<PRE>
public static <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A> <B>mergeObjects</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;first,
                                    <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;second)</PRE>
<DL>
<DD>Static method that merges two objects into a third one. This should be
 done before calling build() on any of these objects and it does not copy
 other properties of the object (like rendering modes etc...).<br>
 Merging objects is quite expensive in terms of memory usage. Merged
 objects are not compressed by default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first object to merge<DD><CODE>second</CODE> - the second object to merge
<DT><B>Returns:</B><DD>the merged object</DL>
</DD>
</DL>
<HR>

<A NAME="mergeAll(com.threed.jpct.Object3D[])"><!-- --></A><H3>
mergeAll</H3>
<PRE>
public static <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A> <B>mergeAll</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>[]&nbsp;objs)</PRE>
<DL>
<DD>Merges all objects in the array into one large object. The array will be
 empty afterwards.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>objs</CODE> - the objects
<DT><B>Returns:</B><DD>the merged result</DL>
</DD>
</DL>
<HR>

<A NAME="resetNextID()"><!-- --></A><H3>
resetNextID</H3>
<PRE>
public static void <B>resetNextID</B>()</PRE>
<DL>
<DD>Resets the internal object-counter. This could be useful in applets,
 where the static class members are not reinitialized when reloading the
 applet.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNextID()"><!-- --></A><H3>
getNextID</H3>
<PRE>
public static int <B>getNextID</B>()</PRE>
<DL>
<DD>Static method that returns the ID the next object will get. This is
 useful to know if (and only if) you want to serialize your world, because
 this value isn't serialized by default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the ID</DL>
</DD>
</DL>
<HR>

<A NAME="setNextID(int)"><!-- --></A><H3>
setNextID</H3>
<PRE>
public static void <B>setNextID</B>(int&nbsp;next)</PRE>
<DL>
<DD>Sets the ID the next object will get. It has to be higher than the
 current one. This method can be used to deserialize a world. Be careful
 when using this method, because screwing up the IDs will most likely
 screw up everything else.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>next</CODE> - the next ID</DL>
</DD>
</DL>
<HR>

<A NAME="compile()"><!-- --></A><H3>
compile</H3>
<PRE>
public void <B>compile</B>()</PRE>
<DL>
<DD>Mainly needed to ease porting from the desktop version of jPCT. By
 default, jPCT-AE does this call automatically, so usually there's no need
 to call this method directly.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="compile(boolean, boolean)"><!-- --></A><H3>
compile</H3>
<PRE>
public void <B>compile</B>(boolean&nbsp;dynamic,
                    boolean&nbsp;staticUV)</PRE>
<DL>
<DD>Mainly needed to ease porting from the desktop version of jPCT. By
 default, jPCT-AE does this call automatically, so usually there's no need
 to call this method directly.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dynamic</CODE> - if the mesh dynamic?<DD><CODE>staticUV</CODE> - does it use static uv-coordinates</DL>
</DD>
</DL>
<HR>

<A NAME="shareCompiledData(com.threed.jpct.Object3D)"><!-- --></A><H3>
shareCompiledData</H3>
<PRE>
public void <B>shareCompiledData</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;withObj)</PRE>
<DL>
<DD>Enables a compiled object to share data with another compiled one. This
 helps to save system or GPU memory, depending on the used mode for
 compilation.<br/>
 The object you would like to share data with must not share data itself
 with some other, it must not use an octree. Furthermore, both objects
 have to use the same mesh (not just the same data but the exact same
 instance), this object must not share data with some other.<br/>
 This object will inherit all texture coordinates and vertex alpha values
 from the source object no matter what may have been assigned to it.<br/>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>withObj</CODE> - the object to share data with</DL>
</DD>
</DL>
<HR>

<A NAME="touch()"><!-- --></A><H3>
touch</H3>
<PRE>
public void <B>touch</B>()</PRE>
<DL>
<DD>Touches an object. This has a meaning for dynamically compiled objects
 and for objects that use lazy transformations. If touched, changes in
 vertices (and u/v-coordinates if supported) will be retransfered to the
 graphics card and the transformation matrices of objects using lazy
 transformations will be recalculated.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="strip()"><!-- --></A><H3>
strip</H3>
<PRE>
public void <B>strip</B>()</PRE>
<DL>
<DD>Frees some memory by stripping some data that isn't needed anymore unless
 you want to modify the object afterwards by using a PolygonManager.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="forceGeometryIndices(boolean)"><!-- --></A><H3>
forceGeometryIndices</H3>
<PRE>
public void <B>forceGeometryIndices</B>(boolean&nbsp;force)</PRE>
<DL>
<DD>Forces the object to be compiled to indexed geometry no matter what.
 Default is false and jPCT will try to figure out, what is best for an
 object. If this is true, it will override this detection. Compiling to
 indexed geometry is more expensive, the result might be smaller in memory
 and depending on the device, it will be rendered faster or slower...<br>
 This has to be set before calling build() to have an effect.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>force</CODE> - should we?</DL>
</DD>
</DL>
<HR>

<A NAME="setAnimationSequence(com.threed.jpct.Animation)"><!-- --></A><H3>
setAnimationSequence</H3>
<PRE>
public void <B>setAnimationSequence</B>(<A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct">Animation</A>&nbsp;anim)</PRE>
<DL>
<DD>Sets the keyframe animation sequence that should be used for this object.
 It is required that the object is already initialized with a frame
 (usually the first) of the animation including texture-coords, -data and
 mesh information. The keyframes of an animation only contain the raw mesh
 data (like getMesh() would return it). Everything else needs to be taken
 from the object itself.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>anim</CODE> - the animation sequence<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct"><CODE>Animation</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#getMesh()"><CODE>getMesh()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="clearAnimation()"><!-- --></A><H3>
clearAnimation</H3>
<PRE>
public void <B>clearAnimation</B>()</PRE>
<DL>
<DD>Clears the animation for this object. The object ist no longer animated.
 Its mesh data will be that of the last frame interpolation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAnimationSequence()"><!-- --></A><H3>
getAnimationSequence</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct">Animation</A> <B>getAnimationSequence</B>()</PRE>
<DL>
<DD>Returns the animation sequence.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the Animation sequence or null if none has been defined</DL>
</DD>
</DL>
<HR>

<A NAME="animate(float, int)"><!-- --></A><H3>
animate</H3>
<PRE>
public void <B>animate</B>(float&nbsp;index,
                    int&nbsp;seq)</PRE>
<DL>
<DD>Calculates a new mesh for this object based on the keyframes of its
 animation sub-sequence and "index". index is a value between 0 and 1
 where 0 is the first keyframe and 1 the last (of the sub-sequence). If
 seq is zero, the whole animation will be treated as a sub-sequence.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - the "time-index" into the sub-sequence of the animation<DD><CODE>seq</CODE> - the number of the sub.sequence (sub-sequence start at 1, 0
            stands for the animation as a whole)</DL>
</DD>
</DL>
<HR>

<A NAME="animate(float)"><!-- --></A><H3>
animate</H3>
<PRE>
public void <B>animate</B>(float&nbsp;index)</PRE>
<DL>
<DD>Calculates a new mesh for this object based on the keyframes of its
 animation sequence and "index". index is a value between 0 and 1 where 0
 is the first keyframe and 1 the last. Because no sub-sequence is
 indicated, the complete animation will be used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - the "time-index" into the animation</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionMode(int)"><!-- --></A><H3>
setCollisionMode</H3>
<PRE>
public void <B>setCollisionMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Sets if and how the object will respond to collisions. Setting mode to
 COLLISION_CHECK_NONE (which is default) means, that the object can't be
 partner in a collision with other objects. Setting it to
 COLLISION_CHECK_OTHERS means that other objects may collide with this
 object and setting it to COLLISION_CHECK_SELF means, that the object
 itself may collide with other objects. The modes may be combined by using
 the or-operator | .
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - The desired mode (COLLISION_CHECK_NONE,
            COLLISION_CHECK_OTHERS, COLLISION_CHECK_SELF or combinations)<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_NONE"><CODE>COLLISION_CHECK_NONE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_OTHERS"><CODE>COLLISION_CHECK_OTHERS</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_SELF"><CODE>COLLISION_CHECK_SELF</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionOptimization(boolean)"><!-- --></A><H3>
setCollisionOptimization</H3>
<PRE>
public void <B>setCollisionOptimization</B>(boolean&nbsp;optimized)</PRE>
<DL>
<DD>Sets an optimization for collision detection to be used/not used. This
 optimization may cause problems on dynamically updated geometry from an
 animation or an IVertexController. Therefor, it's disabled by default.
 Couldn't hurt to try it anyway...:-)<br>
 This optimization affects collisions WITH this object, not OF this
 object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>optimized</CODE> - should the collision detection be optimized or not<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_DETECTION_OPTIMIZED"><CODE>COLLISION_DETECTION_OPTIMIZED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_DETECTION_NOT_OPTIMIZED"><CODE>COLLISION_DETECTION_NOT_OPTIMIZED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setVisibility(boolean)"><!-- --></A><H3>
setVisibility</H3>
<PRE>
public void <B>setVisibility</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Sets the object to visible/invisible. Invisible objects won't be
 processed/rendered at all.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - visible or not<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#OBJ_VISIBLE"><CODE>OBJ_VISIBLE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#OBJ_INVISIBLE"><CODE>OBJ_INVISIBLE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getVisibility()"><!-- --></A><H3>
getVisibility</H3>
<PRE>
public boolean <B>getVisibility</B>()</PRE>
<DL>
<DD>Returns the current visibility state of the object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>object is visible/invisible<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#OBJ_VISIBLE"><CODE>OBJ_VISIBLE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#OBJ_INVISIBLE"><CODE>OBJ_INVISIBLE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcBoundingBox()"><!-- --></A><H3>
calcBoundingBox</H3>
<PRE>
public void <B>calcBoundingBox</B>()</PRE>
<DL>
<DD>Calculates an AABB (Axis Aligned Bounding Box) for this object in
 object-space. The box will then be transformed together with the object
 so that it becomes an OBB (oriented bounding box) when the object will be
 transformed. Normally, there is no need to call this method directly,
 because it will already be called from the build() method. Exceptions
 could be the use of objects meshes for animation and similar tasks.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="build()"><!-- --></A><H3>
build</H3>
<PRE>
public void <B>build</B>()</PRE>
<DL>
<DD>Initializes some basic object properties that are needed for almost all
 further processing. build() has to be called if the object is
 "ready to render" (loaded, Textures assigned, placed, rendering modes
 set, animations and vertex controllers assigned).<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#buildAllObjects()"><CODE>World.buildAllObjects()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="build(boolean)"><!-- --></A><H3>
build</H3>
<PRE>
public void <B>build</B>(boolean&nbsp;staticUV)</PRE>
<DL>
<DD>Initializes some basic object properties that are needed for almost all
 further processing. build() has to be called if the object is
 "ready to render" (loaded, Textures assigned, placed, rendering modes
 set, animations and vertex controllers assigned).<br>
 This method is a special purpose method that has to be used if an
 UV-coordinates are supposed to be modified.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="disableVertexSharing()"><!-- --></A><H3>
disableVertexSharing</H3>
<PRE>
public void <B>disableVertexSharing</B>()</PRE>
<DL>
<DD>Disables the automatic vertex sharing that jPCT does for triangles added
 by addTriangle. This can be useful if single polygons of the object are
 supposed to change their positions independantly from the others (by
 using an IVertexController for example). It will hurt performance though.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hasChild(com.threed.jpct.Object3D)"><!-- --></A><H3>
hasChild</H3>
<PRE>
public boolean <B>hasChild</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Tests an object for being a child object of the current object. A child
 object inherits all the transformations of its parent.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object that should be tested for being a child of this
<DT><B>Returns:</B><DD>true, if obj is a child. Otherwise false.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#hasParent(com.threed.jpct.Object3D)"><CODE>hasParent(com.threed.jpct.Object3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasParent(com.threed.jpct.Object3D)"><!-- --></A><H3>
hasParent</H3>
<PRE>
public boolean <B>hasParent</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Tests an object for being a parent object of the current object. The
 object inherits all the transformations from its parent object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object that should be tested for being a parent of this
<DT><B>Returns:</B><DD>true, if obj is a parent. Otherwise false.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#hasChild(com.threed.jpct.Object3D)"><CODE>hasChild(com.threed.jpct.Object3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addChild(com.threed.jpct.Object3D)"><!-- --></A><H3>
addChild</H3>
<PRE>
public void <B>addChild</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Defines an object as a child of this. A child object will inherit all
 transformations.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object that should become a child of this.</DL>
</DD>
</DL>
<HR>

<A NAME="removeChild(com.threed.jpct.Object3D)"><!-- --></A><H3>
removeChild</H3>
<PRE>
public void <B>removeChild</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Removes an object from the child-collection of this. The object itself
 won't be removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the Object3D to remove</DL>
</DD>
</DL>
<HR>

<A NAME="removeParent(com.threed.jpct.Object3D)"><!-- --></A><H3>
removeParent</H3>
<PRE>
public void <B>removeParent</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Removes an object from the parent-collection of this. The object itself
 won't be removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the Object3D to remove</DL>
</DD>
</DL>
<HR>

<A NAME="addParent(com.threed.jpct.Object3D)"><!-- --></A><H3>
addParent</H3>
<PRE>
public void <B>addParent</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Defines an object as a parent of this. this will inherit all
 transformations from its parent. Defining child and parent object is
 basically the same. Child object of A will internally be stored by
 assigning A as their parent. It's a matter of taste which kind of logic
 one may use. Therefor, both are supported but the parent-logic is closer
 to the implementation...then again: Who cares?
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object that should become a parent of this.</DL>
</DD>
</DL>
<HR>

<A NAME="getParents()"><!-- --></A><H3>
getParents</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>[] <B>getParents</B>()</PRE>
<DL>
<DD>Returns all parents of this Object3D in an array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>all parents</DL>
</DD>
</DL>
<HR>

<A NAME="getID()"><!-- --></A><H3>
getID</H3>
<PRE>
public int <B>getID</B>()</PRE>
<DL>
<DD>Returns the object's ID. The ID is automatically generated and set in the
 constructor. This ID is used to manage the object once it has been added
 to an instance of World. In some cases, it could be necessary to reset
 the ID.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the internal ID of the object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#resetNextID()"><CODE>resetNextID()</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#addObject(com.threed.jpct.Object3D)"><CODE>World.addObject(com.threed.jpct.Object3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getName()"><!-- --></A><H3>
getName</H3>
<PRE>
public java.lang.String <B>getName</B>()</PRE>
<DL>
<DD>Returns the name of the object. By default, this is set to "object" plus
 the object's internal ID. It may be overwritten using setName().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the name of the object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setName(java.lang.String)"><CODE>setName(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setName(java.lang.String)"><!-- --></A><H3>
setName</H3>
<PRE>
public void <B>setName</B>(java.lang.String&nbsp;n)</PRE>
<DL>
<DD>Sets the name of the object to a name other than the default one. The
 name may be used to identify the object in the world's collection of
 objects. Therefore, the name has to be unique.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the new name of the object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#getObjectByName(java.lang.String)"><CODE>World.getObjectByName(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="wasVisible()"><!-- --></A><H3>
wasVisible</H3>
<PRE>
public boolean <B>wasVisible</B>()</PRE>
<DL>
<DD>Returns if the object was visible (or at least supposed to be) in the
 last frame. This can be useful for some rough optimizations on the
 application level, but beware of assuming too much frame coherence. The
 method doesn't take overdraw into account.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if it was visible</DL>
</DD>
</DL>
<HR>

<A NAME="setCulling(boolean)"><!-- --></A><H3>
setCulling</H3>
<PRE>
public void <B>setCulling</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Enables/Disables backface culling for the current object. Backface
 culling is applied to all objects by default. Anyway, some objects may
 require it to be disabled because of the way they are build. Disabling
 backface culling for any object usually double the amount of rendered
 polygons for this object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the culling mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#CULLING_ENABLED"><CODE>CULLING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#CULLING_DISABLED"><CODE>CULLING_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCulling()"><!-- --></A><H3>
getCulling</H3>
<PRE>
public boolean <B>getCulling</B>()</PRE>
<DL>
<DD>Returns the current culling mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>boolean<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#CULLING_ENABLED"><CODE>CULLING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#CULLING_DISABLED"><CODE>CULLING_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setShadingMode(int)"><!-- --></A><H3>
setShadingMode</H3>
<PRE>
public void <B>setShadingMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>jPCT always uses gouraud shading and that can't be disabled. Anyway, with
 this method it's possible to enable a kind of faked flat shading. It will
 look like flat shading, but it isn't any faster than gouraud. It may even
 be slower, because triangle strips and some other optimizations jPCT can
 apply are disabled when using faked flat shading.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the shading mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#SHADING_GOURAUD"><CODE>SHADING_GOURAUD</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#SHADING_FAKED_FLAT"><CODE>SHADING_FAKED_FLAT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setLighting(int)"><!-- --></A><H3>
setLighting</H3>
<PRE>
public void <B>setLighting</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Sets the lighting mode. Default is, that all kinds of light jPCT knows of
 will influence the final lighting of the object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the lighting mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_ALL_ENABLED"><CODE>LIGHTING_ALL_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_NO_LIGHTS"><CODE>LIGHTING_NO_LIGHTS</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLighting()"><!-- --></A><H3>
getLighting</H3>
<PRE>
public int <B>getLighting</B>()</PRE>
<DL>
<DD>Gets the lighting mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_ALL_ENABLED"><CODE>LIGHTING_ALL_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_NO_LIGHTS"><CODE>LIGHTING_NO_LIGHTS</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setSpecularLighting(boolean)"><!-- --></A><H3>
setSpecularLighting</H3>
<PRE>
public void <B>setSpecularLighting</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Enables/Disables specular lighting for the object. The specular lighting
 pass is applied in addition to ambient and diffuse lighting. Specular
 lighting may cause objects to look more reflective and realistic. It
 requires some extra processing but usually it's just a matter of taste if
 it will be used on a particular object or not. Specular lighting is
 disabled by default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the specular mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#SPECULAR_ENABLED"><CODE>SPECULAR_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#SPECULAR_DISABLED"><CODE>SPECULAR_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setTransparency(int)"><!-- --></A><H3>
setTransparency</H3>
<PRE>
public void <B>setTransparency</B>(int&nbsp;trans)</PRE>
<DL>
<DD>Sets the object to be transparent using the given level of transparency.
 In addition to the global transparency of the whole object, every pixel
 with a color of #000000 will be completely transparent (if you don't
 supply an alpha channel with the texture). Note: The current
 implementation doesn't use #000000 but #0f0f0f due to accuracy issues
 with JPEG-compression.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>trans</CODE> - the tranparency level. 0 is the highest possible transparency,
            a value below 0 will disable tranparency for this object</DL>
</DD>
</DL>
<HR>

<A NAME="setShader(com.threed.jpct.GLSLShader)"><!-- --></A><H3>
setShader</H3>
<PRE>
public void <B>setShader</B>(<A HREF="../../../com/threed/jpct/GLSLShader.html" title="class in com.threed.jpct">GLSLShader</A>&nbsp;shader)</PRE>
<DL>
<DD>Sets a shader other than the default shader set. This is only valid when
 using OpenGL ES 2.0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - the shader</DL>
</DD>
</DL>
<HR>

<A NAME="calcTangentVectors()"><!-- --></A><H3>
calcTangentVectors</H3>
<PRE>
public void <B>calcTangentVectors</B>()</PRE>
<DL>
<DD>Tangent vectors are needed for some calculation in shaders. If you are
 using shaders (i.e. OpenGL ES 2.0) and your shader needs these vectors
 and jPCT-AE wasn't able to detect this (by searching for
 "attribute vec4 tangent" in the vertex shader, you might want to trigger
 this calculation manually. By default, the calculation happens
 automatically during build() if the need has been detected.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearShader()"><!-- --></A><H3>
clearShader</H3>
<PRE>
public void <B>clearShader</B>()</PRE>
<DL>
<DD>Removes a shader and reverts to the default shader set. This is only
 valid when using OpenGL ES 2.0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTransparency()"><!-- --></A><H3>
getTransparency</H3>
<PRE>
public int <B>getTransparency</B>()</PRE>
<DL>
<DD>Returns the current tranparency setting.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>int the transparency level</DL>
</DD>
</DL>
<HR>

<A NAME="isTransparent()"><!-- --></A><H3>
isTransparent</H3>
<PRE>
public boolean <B>isTransparent</B>()</PRE>
<DL>
<DD>Returns if the object is transparent of not.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>is it?</DL>
</DD>
</DL>
<HR>

<A NAME="setTransparencyMode(int)"><!-- --></A><H3>
setTransparencyMode</H3>
<PRE>
public void <B>setTransparencyMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Sets the transparency (blending) mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_DEFAULT"><CODE>TRANSPARENCY_MODE_DEFAULT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_ADD"><CODE>TRANSPARENCY_MODE_ADD</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTransparencyMode()"><!-- --></A><H3>
getTransparencyMode</H3>
<PRE>
public int <B>getTransparencyMode</B>()</PRE>
<DL>
<DD>Returns the current transparency mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>int the mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_DEFAULT"><CODE>TRANSPARENCY_MODE_DEFAULT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_ADD"><CODE>TRANSPARENCY_MODE_ADD</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasVertexAlpha()"><!-- --></A><H3>
hasVertexAlpha</H3>
<PRE>
public boolean <B>hasVertexAlpha</B>()</PRE>
<DL>
<DD>Returns true, if this object uses vertex alpha values. False, if it
 doesn't, which is default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>does it?</DL>
</DD>
</DL>
<HR>

<A NAME="setAdditionalColor(com.threed.jpct.RGBColor)"><!-- --></A><H3>
setAdditionalColor</H3>
<PRE>
public void <B>setAdditionalColor</B>(<A HREF="../../../com/threed/jpct/RGBColor.html" title="class in com.threed.jpct">RGBColor</A>&nbsp;col)</PRE>
<DL>
<DD>Sets the additional color for this object. This color will be added to
 the regular color of each vertex (given by ambient, diffuse and specular
 lighting). This can be used to highlight particular objects on purpose.
 The limitation to the range of the AWT's Color doesn't matter here,
 because adding a color brighter than (255,255,255) (jPCT supports this
 overbright lighting) can be useful for lightsources but not for setting a
 color value that isn't processed any further. It simply doesn't get
 whiter than white...:-)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>col</CODE> - the color</DL>
</DD>
</DL>
<HR>

<A NAME="getAdditionalColor()"><!-- --></A><H3>
getAdditionalColor</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/RGBColor.html" title="class in com.threed.jpct">RGBColor</A> <B>getAdditionalColor</B>()</PRE>
<DL>
<DD>Returns the additional color.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the color</DL>
</DD>
</DL>
<HR>

<A NAME="clearAdditionalColor()"><!-- --></A><H3>
clearAdditionalColor</H3>
<PRE>
public void <B>clearAdditionalColor</B>()</PRE>
<DL>
<DD>Removes additional color information form the object. Calling this method
 is equal to call setAdditionalColor(Color.black).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearObject()"><!-- --></A><H3>
clearObject</H3>
<PRE>
public void <B>clearObject</B>()</PRE>
<DL>
<DD>Clears the object by removing all vertex/mesh information from it. This
 also affects objects that have been cloned from this object, because they
 will lose their mesh-data too. Every other property of the object stays
 intact.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#cloneObject()"><CODE>cloneObject()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#decoupleMesh()"><CODE>decoupleMesh()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="decoupleMesh()"><!-- --></A><H3>
decoupleMesh</H3>
<PRE>
public void <B>decoupleMesh</B>()</PRE>
<DL>
<DD>Decouples the current mesh from the object. This may be useful to assign
 another mesh to the object without affecting cloned objects (from this
 object). Without the use of cloned objects, the results of clearObject()
 and decoupleMesh() are the same (= an empty object).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#cloneObject()"><CODE>cloneObject()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#clearObject()"><CODE>clearObject()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setBillboarding(boolean)"><!-- --></A><H3>
setBillboarding</H3>
<PRE>
public void <B>setBillboarding</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Enables/disables billboarding for this object. A billboarded object will
 ingore its own rotation matrix and will always face the camera.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the billboarding mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#BILLBOARDING_ENABLED"><CODE>BILLBOARDING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#BILLBOARDING_DISABLED"><CODE>BILLBOARDING_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isEnvmapped()"><!-- --></A><H3>
isEnvmapped</H3>
<PRE>
public boolean <B>isEnvmapped</B>()</PRE>
<DL>
<DD>Returns if environment mapping is used or not.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>used...or not...<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_ENABLED"><CODE>ENVMAP_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_DISABLED"><CODE>ENVMAP_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setEnvmapped(boolean)"><!-- --></A><H3>
setEnvmapped</H3>
<PRE>
public void <B>setEnvmapped</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Enables/Disables environment mapping for the object. If enabled, the
 texturemap assigned to the object will be used as a spherical environment
 map.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the environment mapping mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_ENABLED"><CODE>ENVMAP_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_DISABLED"><CODE>ENVMAP_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFixedPointMode(boolean)"><!-- --></A><H3>
setFixedPointMode</H3>
<PRE>
public void <B>setFixedPointMode</B>(boolean&nbsp;useFixedPoint)</PRE>
<DL>
<DD>If set to true, some operations will be using fixed point instead of
 floating point. This is less accurate and may cause problems with large
 coordinates, but is usually faster. Default is true.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>useFixedPoint</CODE> - use it?</DL>
</DD>
</DL>
<HR>

<A NAME="rotateX(float)"><!-- --></A><H3>
rotateX</H3>
<PRE>
public void <B>rotateX</B>(float&nbsp;w)</PRE>
<DL>
<DD>Rotates the object's rotation matrix around the x-axis by the given angle
 w (radian, counter clockwise for positive values). This rotation is then
 applied to the object when it's rendered the next time.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w</CODE> - the angle by which should be rotated</DL>
</DD>
</DL>
<HR>

<A NAME="rotateY(float)"><!-- --></A><H3>
rotateY</H3>
<PRE>
public void <B>rotateY</B>(float&nbsp;w)</PRE>
<DL>
<DD>Rotates the object's rotation matrix around the y-axis by the given angle
 w (radian, clockwise for positive values). This rotation is then applied
 to the object when it's rendered the next time.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w</CODE> - the angle by which should be rotated</DL>
</DD>
</DL>
<HR>

<A NAME="rotateZ(float)"><!-- --></A><H3>
rotateZ</H3>
<PRE>
public void <B>rotateZ</B>(float&nbsp;w)</PRE>
<DL>
<DD>Rotates the object's rotation matrix around the z-axis by the given angle
 w (radian, counter clockwise for positive values). This rotation is then
 applied to the object when it's rendered the next time.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w</CODE> - the angle by which should be rotated</DL>
</DD>
</DL>
<HR>

<A NAME="rotateAxis(com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
rotateAxis</H3>
<PRE>
public void <B>rotateAxis</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;axis,
                       float&nbsp;angle)</PRE>
<DL>
<DD>Rotates the object's rotation matrix around an arbitrary axis. The method
 is more powerful than the normal rotate-around-an-axis methods, but also
 a bit slower. The resulting matrix will be orthonormalized to ensure
 numerical stability.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>axis</CODE> - a direction-vector pointing into the axis direction with the
            object's rotation pivot as position vector<DD><CODE>angle</CODE> - the angle of the rotation</DL>
</DD>
</DL>
<HR>

<A NAME="translateMesh()"><!-- --></A><H3>
translateMesh</H3>
<PRE>
public void <B>translateMesh</B>()</PRE>
<DL>
<DD>Translates the raw mesh data using the translation and the origin matrix
 of this object. This translation is applied directly onto the mesh and
 therefor it's permanent. This could be useful for defining animation
 keyframes via object meshes or for altering objects in objectspace.
 Translating a mesh forces the object's bounding box to be recalculated
 afterwards (automatically done).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="translate(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;trans)</PRE>
<DL>
<DD>Translates ("moves") the object in worldspace by modifying the
 translation matrix. The translation will be applied the next time the
 object is rendered.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>trans</CODE> - the translation vector</DL>
</DD>
</DL>
<HR>

<A NAME="translate(float, float, float)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(float&nbsp;x,
                      float&nbsp;y,
                      float&nbsp;z)</PRE>
<DL>
<DD>Translates ("moves") the object in worldspace by modifying the
 translation matrix. The translation will be applied the next time the
 object is rendered.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the number of units the object should be translated parallel
            to the x axis<DD><CODE>y</CODE> - the number of units the object should be translated parallel
            to the y axis<DD><CODE>z</CODE> - the number of units the object should be translated parallel
            to the z axis</DL>
</DD>
</DL>
<HR>

<A NAME="align(com.threed.jpct.Camera)"><!-- --></A><H3>
align</H3>
<PRE>
public void <B>align</B>(<A HREF="../../../com/threed/jpct/Camera.html" title="class in com.threed.jpct">Camera</A>&nbsp;camera)</PRE>
<DL>
<DD>Aligns this object with a Camera using the camera's backbuffer matrix.
 This means that the object (i.e. its positive z-axis) will face into the
 same direction as the camera does. Calling this method modifies the
 object's rotation matrix, but not its translation or origin matrix, i.e.
 the object is facing into the camera's direction but it's not
 automatically placed at the camera's position. This has to be done "by
 hand" if required. Keep in mind that the rotation pivot of this object
 influences the outcome too.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>camera</CODE> - the Camera the Object3D should be aligned with</DL>
</DD>
</DL>
<HR>

<A NAME="align(com.threed.jpct.Object3D)"><!-- --></A><H3>
align</H3>
<PRE>
public void <B>align</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;object)</PRE>
<DL>
<DD>Aligns this object with another Object3D. This basically means that both
 objects will face into the same direction after calling this method. Keep
 in mind that the rotation pivot influences the outcome too. This method
 works on the object's own rotation matrix only. It doesn't take
 transformations of parent objects into account.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - the object this object should be aligned with</DL>
</DD>
</DL>
<HR>

<A NAME="setOrientation(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
setOrientation</H3>
<PRE>
public void <B>setOrientation</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dir,
                           <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;up)</PRE>
<DL>
<DD>Sets the orientation of this object by giving a direction and an
 up-vector.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dir</CODE> - the direction<DD><CODE>up</CODE> - the up-vector</DL>
</DD>
</DL>
<HR>

<A NAME="enableLazyTransformations()"><!-- --></A><H3>
enableLazyTransformations</H3>
<PRE>
public void <B>enableLazyTransformations</B>()</PRE>
<DL>
<DD>Enables "lazy transformations". When lazy transformations are being used,
 the world-transformation matrix (as well as its inverse if needed) is
 calculated only once and used from there on until lazy transformations
 are being disabled again. This helps to improve performance for static
 objects and it can be VERY helpful to speed-up collision detection with
 such objects. It may also be used on none-static objects if they aren't
 moving/rotating for some time (for example: if a lot of objects should be
 checked for collision, it could be helpful to enable lazy transformations
 before doing this and disabling it right after the tests).<br/>
 Enabling this again after it already has been clears the stored values,
 i.e. you can use this to update the calculated matrix inbetween without
 disabling the mode entirely.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#disableLazyTransformations()"><CODE>disableLazyTransformations()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="disableLazyTransformations()"><!-- --></A><H3>
disableLazyTransformations</H3>
<PRE>
public void <B>disableLazyTransformations</B>()</PRE>
<DL>
<DD>Disables "lazy transformations". This is the default setting for every
 new object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#enableLazyTransformations()"><CODE>enableLazyTransformations()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="scale(float)"><!-- --></A><H3>
scale</H3>
<PRE>
public void <B>scale</B>(float&nbsp;scale)</PRE>
<DL>
<DD>Scales the object. A scale-value greater than 1 will result in the object
 to get bigger, while a value lower than 1 causes the object to shrink
 (when transformed...the Mesh won't be touched). Remember that the scales
 (as well as rotations and translations) are cumulative.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scale</CODE> - the new scale<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setScale(float)"><CODE>setScale(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setScale(float)"><!-- --></A><H3>
setScale</H3>
<PRE>
public void <B>setScale</B>(float&nbsp;absScale)</PRE>
<DL>
<DD>Sets an absolute value for the object's scaling. Useful, if the
 cumulative scaling of scale() isn't what one wants.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>absScale</CODE> - the new (absolute) scale<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#scale(float)"><CODE>scale(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getScale()"><!-- --></A><H3>
getScale</H3>
<PRE>
public float <B>getScale</B>()</PRE>
<DL>
<DD>Returns the cumulated scale value for this object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the current scaling</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslation()"><!-- --></A><H3>
getTranslation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getTranslation</B>()</PRE>
<DL>
<DD>Returns the translation of the object (from its origin to its current
 position)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the translation</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslation(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
getTranslation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getTranslation</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;trns)</PRE>
<DL>
<DD>Returns the translation of the object. The returned SimpleVector is the
 same one as the one given as parameter. This is useful to save the
 creation of an additional object. If null is given, a new one will be
 created.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>trns</CODE> - the SimpleVector to fill and return
<DT><B>Returns:</B><DD>the translation</DL>
</DD>
</DL>
<HR>

<A NAME="getOrigin()"><!-- --></A><H3>
getOrigin</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getOrigin</B>()</PRE>
<DL>
<DD>Returns the origin of the object (as set by setOrigin()).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the oring</DL>
</DD>
</DL>
<HR>

<A NAME="getXAxis()"><!-- --></A><H3>
getXAxis</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getXAxis</B>()</PRE>
<DL>
<DD>Returns the x-axis of the object. This is an imaginary axis useful for
 movement und rotations relative to the object. This is based on the
 rotation matrix only. It doesn't take any parent objects into account.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the x-axis</DL>
</DD>
</DL>
<HR>

<A NAME="getYAxis()"><!-- --></A><H3>
getYAxis</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getYAxis</B>()</PRE>
<DL>
<DD>Returns the y-axis of the object. This is an imaginary axis useful for
 movement und rotations relative to the object. This is based on the
 rotation matrix only. It doesn't take any parent objects into account.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the y-axis</DL>
</DD>
</DL>
<HR>

<A NAME="getZAxis()"><!-- --></A><H3>
getZAxis</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getZAxis</B>()</PRE>
<DL>
<DD>Returns the z-axis of the object. This is an imaginary axis useful for
 movement und rotations relative to the object. This is based on the
 rotation matrix only. It doesn't take any parent objects into account.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the z-axis</DL>
</DD>
</DL>
<HR>

<A NAME="getRotationMatrix()"><!-- --></A><H3>
getRotationMatrix</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getRotationMatrix</B>()</PRE>
<DL>
<DD>Returns the object's current rotation matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the rotation matrix of this object</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslationMatrix()"><!-- --></A><H3>
getTranslationMatrix</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getTranslationMatrix</B>()</PRE>
<DL>
<DD>Returns the object's current translation matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the translation matrix of this object</DL>
</DD>
</DL>
<HR>

<A NAME="getOriginMatrix()"><!-- --></A><H3>
getOriginMatrix</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getOriginMatrix</B>()</PRE>
<DL>
<DD>Returns the object's origin-translation matrix. This matrix is a kind of
 static translation matrix for the object used to initially place the
 object into worldspace. Without using child/parent-objects, there is no
 difference between using the translation and the origin matrix, but only
 the former will be applied to child objects of this object. It is advised
 to use the origin matrix to place the object into worldspace once and to
 execute all further translations by using the translation matrix (or by
 using the translate()-method which already does this for you).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the origin-translation matrix of this object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#translate(float, float, float)"><CODE>translate(float,float,float)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setOrigin(com.threed.jpct.SimpleVector)"><CODE>setOrigin(com.threed.jpct.SimpleVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLightCount()"><!-- --></A><H3>
getLightCount</H3>
<PRE>
public int <B>getLightCount</B>()</PRE>
<DL>
<DD>Returns the number of lights that have an influence on this object. This
 is only valid during rendering, i.e. only when called from within an
 IRenderHook.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of used lights</DL>
</DD>
</DL>
<HR>

<A NAME="setRotationMatrix(com.threed.jpct.Matrix)"><!-- --></A><H3>
setRotationMatrix</H3>
<PRE>
public void <B>setRotationMatrix</B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</PRE>
<DL>
<DD>Sets the rotation matrix for the object. Usually, this is not required as
 long as the rotateX/Y/Z() methods are satisfying your needs. If you do
 this, make sure to reset the scale by calling setScale(1f) is you
 previously modified it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mat</CODE> - the new rotation matrix<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#rotateX(float)"><CODE>rotateX(float)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#rotateY(float)"><CODE>rotateY(float)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#rotateZ(float)"><CODE>rotateZ(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="clearRotation()"><!-- --></A><H3>
clearRotation</H3>
<PRE>
public void <B>clearRotation</B>()</PRE>
<DL>
<DD>Resets the current rotation to the initial value, i.e. no rotation at
 all.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearTranslation()"><!-- --></A><H3>
clearTranslation</H3>
<PRE>
public void <B>clearTranslation</B>()</PRE>
<DL>
<DD>Resets the current translation to the initial value, i.e. no translation
 at all.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTextureMatrix(com.threed.jpct.Matrix)"><!-- --></A><H3>
setTextureMatrix</H3>
<PRE>
public void <B>setTextureMatrix</B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</PRE>
<DL>
<DD>Sets a matrix that is applied to transform the texture in stage 0. If no
 transformation is needed, null should be set instead of an empty matrix.<br/>
 Note: This doesn't work on all phones. On a Samsung Galaxy with Android
 1.5 for example, changing the texture matrix has no effect!?
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mat</CODE> - the matrix</DL>
</DD>
</DL>
<HR>

<A NAME="getTextureMatrix()"><!-- --></A><H3>
getTextureMatrix</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getTextureMatrix</B>()</PRE>
<DL>
<DD>Returns the current texture matrix of null if none is set.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="rotateMesh()"><!-- --></A><H3>
rotateMesh</H3>
<PRE>
public void <B>rotateMesh</B>()</PRE>
<DL>
<DD>Rotates the raw mesh data using the rotation matrix specified for this
 object. This rotation is applied directly onto the mesh and therefor it's
 permanent. This could be useful for defining animation keyframes via
 object meshes or for altering objects in objectspace. Rotating a mesh
 forces the object's bounding box to be recalculated afterwards
 (automatically done). The rotation matrix of the object won't be reset by
 this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTranslationMatrix(com.threed.jpct.Matrix)"><!-- --></A><H3>
setTranslationMatrix</H3>
<PRE>
public void <B>setTranslationMatrix</B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</PRE>
<DL>
<DD>Sets the translation matrix for the object. Usually, this is not required
 as long as the translate() method is satisfying your needs.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mat</CODE> - the new translation matrix<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#translate(float, float, float)"><CODE>translate(float,float,float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setMesh(com.threed.jpct.Mesh)"><!-- --></A><H3>
setMesh</H3>
<PRE>
public void <B>setMesh</B>(<A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct">Mesh</A>&nbsp;mesh)</PRE>
<DL>
<DD>Sets an object's mesh to another one. Shouldn't be required in normal
 applications.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mesh</CODE> - the new mesh of the object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#getMesh()"><CODE>getMesh()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#calcBoundingBox()"><CODE>calcBoundingBox()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMesh()"><!-- --></A><H3>
getMesh</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct">Mesh</A> <B>getMesh</B>()</PRE>
<DL>
<DD>Returns the current mesh of the object. This is useful for using an
 object's mesh data as keyframes for an animation. The returned mesh can
 also be added to another object by using setMesh(). If you do so, both
 objects will share the same instance of mesh. That isn't a problem as
 long as you don't want to modify the mesh of one object without changing
 the other's. In this case, you should better use a copy of the mesh
 obtained from Mesh.cloneMesh().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the object's mesh<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct"><CODE>Animation</CODE></A>, 
<A HREF="../../../com/threed/jpct/Mesh.html#cloneMesh(boolean)"><CODE>Mesh.cloneMesh(boolean)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setMesh(com.threed.jpct.Mesh)"><CODE>setMesh(com.threed.jpct.Mesh)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPolygonManager()"><!-- --></A><H3>
getPolygonManager</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/PolygonManager.html" title="class in com.threed.jpct">PolygonManager</A> <B>getPolygonManager</B>()</PRE>
<DL>
<DD>Returns the PolygonManager for this object. A PolygonManager can be used
 to access an object's polygons. While you can obtain a PolygonManager
 from a stripped object, you can't safely modify the object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the manager<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#strip()"><CODE>strip()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setBoundingBox(float, float, float, float, float, float)"><!-- --></A><H3>
setBoundingBox</H3>
<PRE>
public void <B>setBoundingBox</B>(float&nbsp;minx,
                           float&nbsp;maxx,
                           float&nbsp;miny,
                           float&nbsp;maxy,
                           float&nbsp;minz,
                           float&nbsp;maxz)</PRE>
<DL>
<DD>Sets a new AABB for the object. Usually, this shouldn't be required as it
 is automatically done by the build()-method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>minx</CODE> - the lowest x-value of the AABB<DD><CODE>maxx</CODE> - the highest x-value of the AABB<DD><CODE>miny</CODE> - the lowest y-value of the AABB<DD><CODE>maxy</CODE> - the highest y-value of the AABB<DD><CODE>minz</CODE> - the lowest z-value of the AABB<DD><CODE>maxz</CODE> - the highest z-value of the AABB<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#calcBoundingBox()"><CODE>calcBoundingBox()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cloneObject()"><!-- --></A><H3>
cloneObject</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A> <B>cloneObject</B>()</PRE>
<DL>
<DD>Clones the current object. A cloned object A' of an object A is a copy of
 A at the point when the cloning takes places. This means that A' inherits
 all rotations, translations and rendering properties from A. However, A'
 and A are sharing the same mesh data (to save memory). This will cause A'
 to inherit all keyframe animations from A and vice versa. Keep this in
 mind when cloning animated objects. Cloning an object is a costly
 operation that should only be done when needed. If multiple copies of an
 object are required during runtime, it may be helpful to create them at
 startup. This method also copies properties like lazy transformation
 settings and similar, so take care to adjust afterwards on the cloned
 object if needed. Cloning doesn't clone collision modes.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the cloned object</DL>
</DD>
</DL>
<HR>

<A NAME="getWorldTransformation()"><!-- --></A><H3>
getWorldTransformation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getWorldTransformation</B>()</PRE>
<DL>
<DD>Returns the transformation matrix used to transform the object from
 objectspace into worldspace. Could be useful for debugging purposes, but
 usually this information shouldn't be needed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the transformation matrix</DL>
</DD>
</DL>
<HR>

<A NAME="getWorldTransformation(com.threed.jpct.Matrix)"><!-- --></A><H3>
getWorldTransformation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getWorldTransformation</B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</PRE>
<DL>
<DD>Variant of getWorldTransformation() to avoid the creation of an
 additional matrix where not needed. The given matrix will be filled with
 the returns and returned in addition.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mat</CODE> - the matrix to be filled
<DT><B>Returns:</B><DD>the transformation matrix</DL>
</DD>
</DL>
<HR>

<A NAME="addCollisionListener(com.threed.jpct.CollisionListener)"><!-- --></A><H3>
addCollisionListener</H3>
<PRE>
public void <B>addCollisionListener</B>(<A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct">CollisionListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Adds a collision listener to this object. A collision listener gets
 notified in case of a collision with or caused by this object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the listener<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct"><CODE>CollisionListener</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeCollisionListener(com.threed.jpct.CollisionListener)"><!-- --></A><H3>
removeCollisionListener</H3>
<PRE>
public void <B>removeCollisionListener</B>(<A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct">CollisionListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Removes a collision listener from the list of listeners.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the listener to remove</DL>
</DD>
</DL>
<HR>

<A NAME="disableCollisionListeners()"><!-- --></A><H3>
disableCollisionListeners</H3>
<PRE>
public void <B>disableCollisionListeners</B>()</PRE>
<DL>
<DD>Disables all collision listeners of this object, so that none of them
 will be notified in case of a collision.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="enableCollisionListeners()"><!-- --></A><H3>
enableCollisionListeners</H3>
<PRE>
public void <B>enableCollisionListeners</B>()</PRE>
<DL>
<DD>(Re-)enables all collision listerner of this object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCollisionListeners()"><!-- --></A><H3>
getCollisionListeners</H3>
<PRE>
public java.util.Iterator&lt;<A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct">CollisionListener</A>&gt; <B>getCollisionListeners</B>()</PRE>
<DL>
<DD>Returns the collision listeners of this object as an enumeration. The
 enumeration is empty if no listeners have been assigned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the listeners</DL>
</DD>
</DL>
<HR>

<A NAME="setRenderHook(com.threed.jpct.IRenderHook)"><!-- --></A><H3>
setRenderHook</H3>
<PRE>
public void <B>setRenderHook</B>(<A HREF="../../../com/threed/jpct/IRenderHook.html" title="interface in com.threed.jpct">IRenderHook</A>&nbsp;hook)</PRE>
<DL>
<DD>Sets a new hook into the rendering pipeline. This is only valid for
 compiled objects. Any other object will never access this hook. The hook
 won't be serialized if the Object3D is.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hook</CODE> - the hook into the rendering pipeline<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/IRenderHook.html" title="interface in com.threed.jpct"><CODE>IRenderHook</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkForCollision(com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
checkForCollision</H3>
<PRE>
public int <B>checkForCollision</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dirVec,
                             float&nbsp;step)</PRE>
<DL>
<DD>Checks if the current object collides with something when moving into a
 particular direction. This is just a check, so no translations are being
 performed. A collision can only be detected with objects that are set to
 COLLISION_CHECK_OTHERS. This method uses a ray-polygon collision
 detection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dirVec</CODE> - the direction vector (a unit vector)<DD><CODE>step</CODE> - the length of the casted ray (a collision will only be
            detected of it takes place within this range)
<DT><B>Returns:</B><DD>the ID of the Object3D if there is a collision, otherwise
         NO_OBJECT<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setCenter(com.threed.jpct.SimpleVector)"><CODE>setCenter(com.threed.jpct.SimpleVector)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setCollisionMode(int)"><CODE>setCollisionMode(int)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#getID()"><CODE>getID()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#NO_OBJECT"><CODE>NO_OBJECT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkForCollisionSpherical(com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
checkForCollisionSpherical</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>checkForCollisionSpherical</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                                               float&nbsp;radius)</PRE>
<DL>
<DD>Checks if the current object collides with something when moving into a
 particular direction. This is just a check, so no translations are being
 performed. A collision can only be detected with objects that are set to
 COLLISION_CHECK_OTHERS. This method uses a sphere-polygon collision
 detection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>translation</CODE> - the translation the object should perform<DD><CODE>radius</CODE> - the radius of the sphere (a collision will only be detected of
            it takes place within this radius)
<DT><B>Returns:</B><DD>a SimpleVector containing a corrected translation vector. This
         vector represents the translation that should be applied to the
         object to avoid a collision. If no collision takes place, the
         translation won't be corrected though (i.e. no collision means
         returned SimpleVector.equals(translation))<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setCenter(com.threed.jpct.SimpleVector)"><CODE>setCenter(com.threed.jpct.SimpleVector)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setCollisionMode(int)"><CODE>setCollisionMode(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkForCollisionEllipsoid(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, int)"><!-- --></A><H3>
checkForCollisionEllipsoid</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>checkForCollisionEllipsoid</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                                               <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid,
                                               int&nbsp;recursionDepth)</PRE>
<DL>
<DD>Checks if the current object collides with something when moving into a
 particular direction. This is just a check, so no translations are being
 performed. A collision can only be detected with objects that are set to
 COLLISION_CHECK_OTHERS. This method uses a (swept)ellipsoid-polygon
 collision detection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>translation</CODE> - the translation the object should perform<DD><CODE>ellipsoid</CODE> - the radius of the epplisoid in x,y and z direction<DD><CODE>recursionDepth</CODE> - the max. recursion depth of the collision detection. A higher
            value will improve the accuracy of the collision detection but
            reduce performance. Reasonable values lie between 1 and 5.
<DT><B>Returns:</B><DD>a SimpleVector containing a corrected translation vector. This
         vector represents the translation that should be applied to the
         object to avoid a collision. If no collision takes place, the
         translation won't be corrected though (i.e. no collision means
         returned SimpleVector.equals(translation))<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setCenter(com.threed.jpct.SimpleVector)"><CODE>setCenter(com.threed.jpct.SimpleVector)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setCollisionMode(int)"><CODE>setCollisionMode(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setEllipsoidMode(int)"><!-- --></A><H3>
setEllipsoidMode</H3>
<PRE>
public void <B>setEllipsoidMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>When doing ellipsoid collision detection with this object, the ellipsoid
 can be transformed according to the objects's transformation and in the
 source's object space or it remains static in the target's object space
 (i.e. "axis aligned"). <br>
 The later is faster, but not suitable for all kinds of ellipsoids.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - int the mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_ALIGNED"><CODE>ELLIPSOID_ALIGNED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_TRANSFORMED"><CODE>ELLIPSOID_TRANSFORMED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getEllipsoidMode()"><!-- --></A><H3>
getEllipsoidMode</H3>
<PRE>
public int <B>getEllipsoidMode</B>()</PRE>
<DL>
<DD>Returns the current ellipsoid mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_ALIGNED"><CODE>ELLIPSOID_ALIGNED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_TRANSFORMED"><CODE>ELLIPSOID_TRANSFORMED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="wasTargetOfLastCollision()"><!-- --></A><H3>
wasTargetOfLastCollision</H3>
<PRE>
public boolean <B>wasTargetOfLastCollision</B>()</PRE>
<DL>
<DD>True, if this object was a target of the last collision detection that
 took place (regardless of what kind it was). Otherwise false. "A target"
 in this context means, that something has collided with this object, i.e.
 if one checks object A for collision with other objects and it collides
 with an object B, B is the target and A is the source. A collision is not
 automatically detected. One has to use one of the various ways jPCT
 offers for collision detection to detect it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>was this object a target of the last detected collision?<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#resetCollisionStatus()"><CODE>resetCollisionStatus()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="resetCollisionStatus()"><!-- --></A><H3>
resetCollisionStatus</H3>
<PRE>
public void <B>resetCollisionStatus</B>()</PRE>
<DL>
<DD>Sets the indicator that the object was a target of the last collision
 detection to false, i.e. the object won't be recognized any longer as
 part of the collision. This is done automatically the next time a
 collision detection method is being called.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#wasTargetOfLastCollision()"><CODE>wasTargetOfLastCollision()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcMinDistance(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
calcMinDistance</H3>
<PRE>
public float <B>calcMinDistance</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                             <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr)</PRE>
<DL>
<DD>Returns the minimal distance to some polygon of the object from a
 particular position vector looking into a specific direction.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - a SimpleVector containing the position vector<DD><CODE>dr</CODE> - a SimpleVector containing the direction vector
<DT><B>Returns:</B><DD>the minimal distance to some polygon (= how far can one move into
         this direction until something will be hit). If there is no such
         polygon, COLLISION_NONE will be returned.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_NONE"><CODE>COLLISION_NONE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcMinDistance(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
calcMinDistance</H3>
<PRE>
public float <B>calcMinDistance</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                             <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr,
                             float&nbsp;ignoreIfLarger)</PRE>
<DL>
<DD>Returns the minimal distance to some polygon of the object from a
 particular position vector looking into a specific direction. This
 version is a special purpose version of calcMinDistance() which only
 takes polygons into consideration that have at least one vertex that is
 closer than ignoreIfLarger units to the position vector. Can be useful to
 optimize calculations in situations where it is known how far away the
 polygon with the minimal distance can be at max.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - a SimpleVector containing the position vector<DD><CODE>dr</CODE> - a SimpleVector containing the direction vector<DD><CODE>ignoreIfLarger</CODE> - only polygons within this range will be taken into account
<DT><B>Returns:</B><DD>the minimal distance to some polygon (= how far can one move into
         this direction until something will be hit). If there is no such
         polygon, COLLISION_NONE will be returned.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_NONE"><CODE>COLLISION_NONE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setCenter(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
setCenter</H3>
<PRE>
public void <B>setCenter</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;center)</PRE>
<DL>
<DD>Sets the center of the object (in object-space). This "center" doesn't
 has to be the real center of the object but it's the point in objectspace
 which will be used for collision detection. This means that if one tests
 if the object may move A units into (x,y,z)-direction, actually it's
 tested if this point (transformed into world-space) may move A units into
 (x,y,z)-direction. Calling build() resets this value to a calculated
 center, so this method should be called after calling build().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>center</CODE> - the center<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCenter()"><!-- --></A><H3>
getCenter</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getCenter</B>()</PRE>
<DL>
<DD>Returns the center of the object (in object-space, i.e. unaffected by any
 transformation).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the center</DL>
</DD>
</DL>
<HR>

<A NAME="getTransformedCenter()"><!-- --></A><H3>
getTransformedCenter</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getTransformedCenter</B>()</PRE>
<DL>
<DD>Returns the center of the object in worldspace, i.e. after the object's
 current transformations have been applied to it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the center transformed into worldspace</DL>
</DD>
</DL>
<HR>

<A NAME="getTransformedCenter(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
getTransformedCenter</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getTransformedCenter</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;toFill)</PRE>
<DL>
<DD>Returns the center of the object in worldspace, i.e. after the object's
 current transformations have been applied to it. The returned
 SimpleVector is the same one as the one given as parameter. This is
 useful to save the creation of an additional object. If null is given, a
 new one will be created.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the center transformed into worldspace</DL>
</DD>
</DL>
<HR>

<A NAME="setRotationPivot(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
setRotationPivot</H3>
<PRE>
public void <B>setRotationPivot</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;pivot)</PRE>
<DL>
<DD>Sets the rotation pivot of the object. The rotation pivot is the point in
 objectspace around which the object will be rotated using its rotation
 matrix. Calling build() resets this value to a calculated rotation pivot,
 so this method should be called after calling build().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pivot</CODE> - the rotation pivot<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRotationPivot()"><!-- --></A><H3>
getRotationPivot</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getRotationPivot</B>()</PRE>
<DL>
<DD>Returns the rotation pivot of the object
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the rotation pivot</DL>
</DD>
</DL>
<HR>

<A NAME="calcCenter()"><!-- --></A><H3>
calcCenter</H3>
<PRE>
public void <B>calcCenter</B>()</PRE>
<DL>
<DD>Tries to calculate the center of the object using its mesh data. This is
 a very rough approach and while it works very well on most objects, it
 may fail on others. This method sets both the center and the rotation
 pivot. This method is called by the build() method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setCenter(com.threed.jpct.SimpleVector)"><CODE>setCenter(com.threed.jpct.SimpleVector)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setRotationPivot(com.threed.jpct.SimpleVector)"><CODE>setRotationPivot(com.threed.jpct.SimpleVector)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setOcTree(com.threed.jpct.OcTree)"><!-- --></A><H3>
setOcTree</H3>
<PRE>
public void <B>setOcTree</B>(<A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct">OcTree</A>&nbsp;ocTree)</PRE>
<DL>
<DD>Assigns an octree to the object. An octree may help to increase
 performance for some kind of objects (like large landscapes). It's not
 possible to combine portals and octrees (at least not in jPCT), so
 setting the octree will be ignored if portal rendering is enabled. In
 every other case, the object will be rendered using the octree as soon as
 it's assigned to it.<br>
 Please keep in mind that calculating triangle strips has to be done
 before building/assigning the tree, because it will destroy the tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ocTree</CODE> - the octree that subdivides this object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct"><CODE>OcTree</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getOcTree()"><!-- --></A><H3>
getOcTree</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct">OcTree</A> <B>getOcTree</B>()</PRE>
<DL>
<DD>Returns the OcTree assigned to this object or null, if none has been
 assigned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the OcTree (or null)</DL>
</DD>
</DL>
<HR>

<A NAME="setOrigin(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
setOrigin</H3>
<PRE>
public void <B>setOrigin</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;origin)</PRE>
<DL>
<DD>Sets the origin of the object. The origin is a position in worldspace at
 which the object will be placed before performing any other translations.
 The difference between the origin and a normal translation is, that the
 normal translation affects the child objects (if any) while the
 translation to the origin doesn't.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>origin</CODE> - the origin<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#translate(float, float, float)"><CODE>translate(float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="invert()"><!-- --></A><H3>
invert</H3>
<PRE>
public void <B>invert</B>()</PRE>
<DL>
<DD>Physically "inverts" the object, which means that the backface culling
 works the other way round. This could be used for example on a cube that
 is usually viewed from outside to make it possible to view it from the
 inside (and still use backface culling on it). Inverting an object is a
 costly operation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="invertCulling(boolean)"><!-- --></A><H3>
invertCulling</H3>
<PRE>
public void <B>invertCulling</B>(boolean&nbsp;inv)</PRE>
<DL>
<DD>Inverts culling order if set to true. This affects culling only, not the
 mesh itself (unlike invert()).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inv</CODE> - invert the culling?</DL>
</DD>
</DL>
<HR>

<A NAME="cullingIsInverted()"><!-- --></A><H3>
cullingIsInverted</H3>
<PRE>
public boolean <B>cullingIsInverted</B>()</PRE>
<DL>
<DD>Returns true, if inverted culling is used on this object. False
 otherwise.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>is it?</DL>
</DD>
</DL>
<HR>

<A NAME="calcNormals()"><!-- --></A><H3>
calcNormals</H3>
<PRE>
public void <B>calcNormals</B>()</PRE>
<DL>
<DD>Calculates the object's vertex normals by calculating the face normals of
 the adjacent polygons of each vertex and averaging them. The normals are
 required for lighting and mapping, so they need to be calculated for
 every object. Usually, this is already done by calling the object's
 build() method. (Respective by the loader for MD2-files). jPCT has two
 different methods for calculating the normals. One is faster for smaller
 objects while the other one is (much!) faster for more complex objects.
 jPCT automatically decides which method to use depending on the object
 and the value of optimizeNormalCalcTH in Config.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcTextureWrap()"><!-- --></A><H3>
calcTextureWrap</H3>
<PRE>
public void <B>calcTextureWrap</B>()</PRE>
<DL>
<DD>"Wraps" a texture around the object. This may not look correct on every
 object, but it's a fast and easy way to assign texture coordinates to
 objects that didn't have any. This kind of wrapping is basically a kind
 of static environment mapping.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#calcTextureWrapSpherical()"><CODE>calcTextureWrapSpherical()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcTextureWrapSpherical()"><!-- --></A><H3>
calcTextureWrapSpherical</H3>
<PRE>
public void <B>calcTextureWrapSpherical</B>()</PRE>
<DL>
<DD>"Wraps" a texture around the object in a spherical way. Usually, this
 method produces better results than calcTextureWrap(), but it depends on
 the object. This method is well suited to assign texture-coordinates to
 objects that were generated using the Primitives class. This method
 recalculates the center of the object, so any modification to the center
 or the rotation-pivot will be lost after calling this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#calcTextureWrap()"><CODE>calcTextureWrap()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Primitives.html" title="class in com.threed.jpct"><CODE>Primitives</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setTexture(java.lang.String)"><!-- --></A><H3>
setTexture</H3>
<PRE>
public void <B>setTexture</B>(java.lang.String&nbsp;texname)</PRE>
<DL>
<DD>Sets the texture for the object. When using normal texturemapping, this
 texture is the only one used. With environment mapping enabled, this
 texture is used as an environment map. With environment bumpmapping
 enabled, this texture is pertubed by the bumpmap.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texname</CODE> - the name of the texture as set in the
            TextureManager.addTexture()-method</DL>
</DD>
</DL>
<HR>

<A NAME="setTexture(com.threed.jpct.TextureInfo)"><!-- --></A><H3>
setTexture</H3>
<PRE>
public void <B>setTexture</B>(<A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf)</PRE>
<DL>
<DD>Sets the texture for the object via an instance of TextureInfo.<br/>
 Texture coordinates for all layers are taken from the coordinates defined
 for the base layer of the Object3D.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tInf</CODE> - the TextureInfo<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct"><CODE>TextureInfo</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="rayIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, boolean)"><!-- --></A><H3>
rayIntersectsAABB</H3>
<PRE>
public float <B>rayIntersectsAABB</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                               <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr,
                               boolean&nbsp;isNormalized)</PRE>
<DL>
<DD>Checks if a given ray intersects with the axis aligned bounding box (in
 object-space) of this object. This can be useful to speed up some
 calculations. jPCT is using this method for faster collision detection. <br>
 If the object doesn't have a bounding box for whatever reason,
 RAY_MISSES_BOX will be returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - the position vector of the ray<DD><CODE>dr</CODE> - the direction vector of the ray<DD><CODE>isNormalized</CODE> - indicates, that dr is already normalized. So the method can
            spare another normalization.
<DT><B>Returns:</B><DD>the distance between the starting point of the ray and the
         nearest plane of the box. If the ray doesn't intersect the box,
         RAY_MISSES_BOX will be returned<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#RAY_MISSES_BOX"><CODE>RAY_MISSES_BOX</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="rayIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
rayIntersectsAABB</H3>
<PRE>
public float <B>rayIntersectsAABB</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                               <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr)</PRE>
<DL>
<DD>Checks if a given ray intersects with the axis aligned bounding box (in
 object-space) of this object. This can be useful to speed up some
 calculations. jPCT is using this method for faster collision detection. <br>
 If the object doesn't have a bounding box for whatever reason,
 RAY_MISSES_BOX will be returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - the position vector of the ray<DD><CODE>dr</CODE> - the direction vector of the ray
<DT><B>Returns:</B><DD>the distance between the starting point of the ray and the
         nearest plane of the box. If the ray doesn't intersect the box,
         RAY_MISSES_BOX will be returned<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#RAY_MISSES_BOX"><CODE>RAY_MISSES_BOX</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="ellipsoidIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
ellipsoidIntersectsAABB</H3>
<PRE>
public boolean <B>ellipsoidIntersectsAABB</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid)</PRE>
<DL>
<DD>Checks if a given ellipsoid intersects the axis aligned bounding box (in
 object-space) of this object. This can be useful to speed up some
 calculations. jPCT is using this method for faster collision detection.
 "Intersection" means everything from touching it to being completely
 covered by it in this case. <br>
 If the object doesn't have a bounding box for whatever reason, false will
 be returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - the position vector of the ellipsoid (the ellipsoid's center)<DD><CODE>ellipsoid</CODE> - the radius of the ellipsoid in x,y and z-direction as a
            SimpleVector
<DT><B>Returns:</B><DD>true if there is an intersection, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="sphereIntersectsAABB(com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
sphereIntersectsAABB</H3>
<PRE>
public boolean <B>sphereIntersectsAABB</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                                    float&nbsp;radius)</PRE>
<DL>
<DD>Checks if a given sphere intersects the axis aligned bounding box (in
 object-space) of this object. This can be useful to speed up some
 calculations. jPCT is using this method for faster collision detection.
 "Intersection" means everything from touching it to being completely
 covered by it in this case.<br>
 If the object doesn't have a bounding box for whatever reason, false will
 be returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - the position vector of the sphere (the sphere's center)<DD><CODE>radius</CODE> - the radius of the sphere
<DT><B>Returns:</B><DD>true if there is an intersection, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3)</PRE>
<DL>
<DD>Adds a triangle to the object. Using the method, the texture of the
 object won't be set and the sector will be set to undefined. Texture
 coordinates won't be set (= set to (0,0) for all vertices). The vertices
 have to be defined counter-clockwise because jPCT backface culls them by
 default. One may also add them clockwise and call invert() afterwards to
 "invert" the order.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>vert3</CODE> - the third vertex
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       float&nbsp;u,
                       float&nbsp;v,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       float&nbsp;u2,
                       float&nbsp;v2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
                       float&nbsp;u3,
                       float&nbsp;v3)</PRE>
<DL>
<DD>Adds a triangle to the object. Using the method, the texture of the
 object won't be set and the sector will be set to undefined. The vertices
 have to be defined counter-clockwise because jPCT backface culls them by
 default. One may also add them clockwise and call invert() afterwards to
 "invert" the order.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>u</CODE> - the u component of the texture position at the first vertex<DD><CODE>v</CODE> - the v component of the texture position at the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>u2</CODE> - the u component of the texture position at the second vertex<DD><CODE>v2</CODE> - the v component of the texture position at the second vertex<DD><CODE>vert3</CODE> - the third vertex<DD><CODE>u3</CODE> - the u component of the texture position at the third vertex<DD><CODE>v3</CODE> - the v component of the texture position at the third vertex
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, int)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       float&nbsp;u,
                       float&nbsp;v,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       float&nbsp;u2,
                       float&nbsp;v2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
                       float&nbsp;u3,
                       float&nbsp;v3,
                       int&nbsp;textureID)</PRE>
<DL>
<DD>Adds a triangle to the object. Using the method, the sector will be set
 to undefined. The vertices have to be defined counter-clockwise because
 jPCT backface culls them by default. One may also add them clockwise and
 call invert() afterwards to "invert" the order.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>u</CODE> - the u component of the texture position at the first vertex<DD><CODE>v</CODE> - the v component of the texture position at the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>u2</CODE> - the u component of the texture position at the second vertex<DD><CODE>v2</CODE> - the v component of the texture position at the second vertex<DD><CODE>vert3</CODE> - the third vertex<DD><CODE>u3</CODE> - the u component of the texture position at the third vertex<DD><CODE>v3</CODE> - the v component of the texture position at the third vertex<DD><CODE>textureID</CODE> - the ID of the texture as returned by
            TextureManager.getTextureID()
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/TextureManager.html#getTextureID(java.lang.String)"><CODE>TextureManager.getTextureID(java.lang.String)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, int, int)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       float&nbsp;u,
                       float&nbsp;v,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       float&nbsp;u2,
                       float&nbsp;v2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
                       float&nbsp;u3,
                       float&nbsp;v3,
                       int&nbsp;textureID,
                       int&nbsp;sec)</PRE>
<DL>
<DD>Adds a triangle to the object. The vertices have to be defined
 counter-clockwise because jPCT backface culls them by default. One may
 also add them clockwise and call invert() afterwards to "invert" the
 order.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>u</CODE> - the u component of the texture position at the first vertex<DD><CODE>v</CODE> - the v component of the texture position at the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>u2</CODE> - the u component of the texture position at the second vertex<DD><CODE>v2</CODE> - the v component of the texture position at the second vertex<DD><CODE>vert3</CODE> - the third vertex<DD><CODE>u3</CODE> - the u component of the texture position at the third vertex<DD><CODE>v3</CODE> - the v component of the texture position at the third vertex<DD><CODE>textureID</CODE> - the ID of the texture as returned by
            TextureManager.getTextureID()
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/TextureManager.html#getTextureID(java.lang.String)"><CODE>TextureManager.getTextureID(java.lang.String)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.TextureInfo)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
                       <A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf)</PRE>
<DL>
<DD>Adds a triangle to the object. The vertices have to be defined
 counter-clockwise because jPCT backface culls them by default. One may
 also add them clockwise and call invert() afterwards to "invert" the
 order.<br>
 This method takes a TextureInfo instead of the discrete u/v-coordinates
 and the textureID.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>vert3</CODE> - the third vertex<DD><CODE>tInf</CODE> - the TextureInfo
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/TextureManager.html#getTextureID(java.lang.String)"><CODE>TextureManager.getTextureID(java.lang.String)</CODE></A>, 
<A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct"><CODE>TextureInfo</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getInverseWorldTransformation()"><!-- --></A><H3>
getInverseWorldTransformation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getInverseWorldTransformation</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInverseWorldTransformation(com.threed.jpct.Matrix)"><!-- --></A><H3>
getInverseWorldTransformation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getInverseWorldTransformation</B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Object3D.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/threed/jpct/Object3D.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Object3D.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
